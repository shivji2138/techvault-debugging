<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DEBUG TERMINAL | Cyber Arena</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700;900&family=JetBrains+Mono:wght@300;400;600&display=swap" rel="stylesheet">
<link rel="stylesheet" data-name="vs/editor/editor.main" href="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/editor/editor.main.min.css">
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<style>
:root {
  --neon: #00ff88;
  --neon-dim: #00cc6a;
  --neon-glow: rgba(0,255,136,0.3);
  --red: #ff2244;
  --red-glow: rgba(255,34,68,0.4);
  --bg: #050a07;
  --bg2: #0a120d;
  --bg3: #0d1a10;
  --border: rgba(0,255,136,0.2);
  --text: #c8ffd4;
  --text-dim: #5a8a68;
}
* { box-sizing: border-box; margin: 0; padding: 0; }
html, body { width:100%; height:100%; overflow:hidden; background:var(--bg); color:var(--text); font-family:'JetBrains Mono', monospace; }
#root { width:100%; height:100%; }

#matrix-canvas { position:fixed; top:0; left:0; width:100%; height:100%; z-index:0; opacity:0.12; pointer-events:none; }

/* ===== SCROLLBARS ===== */
::-webkit-scrollbar { width:6px; height:6px; }
::-webkit-scrollbar-track { background:var(--bg); }
::-webkit-scrollbar-thumb { background:var(--neon-dim); border-radius:3px; }

/* ===== GLOW EFFECTS ===== */
.neon-glow { text-shadow: 0 0 10px var(--neon), 0 0 30px var(--neon-glow); }
.neon-border { border: 1px solid var(--neon); box-shadow: 0 0 10px var(--neon-glow), inset 0 0 10px rgba(0,255,136,0.05); }
.red-glow { text-shadow: 0 0 10px var(--red), 0 0 30px var(--red-glow); color: var(--red) !important; }
.red-border { border: 1px solid var(--red) !important; box-shadow: 0 0 10px var(--red-glow), inset 0 0 10px rgba(255,34,68,0.05) !important; }
.pulse-border { animation: pulseBorder 2s ease-in-out infinite; }

/* ===== ANIMATIONS ===== */
@keyframes pulseBorder {
  0%,100% { box-shadow: 0 0 8px var(--neon-glow), inset 0 0 8px rgba(0,255,136,0.03); }
  50% { box-shadow: 0 0 20px var(--neon-glow), inset 0 0 15px rgba(0,255,136,0.08); }
}
@keyframes pulseBorderRed {
  0%,100% { box-shadow: 0 0 8px var(--red-glow); border-color: var(--red); }
  50% { box-shadow: 0 0 25px var(--red-glow); border-color: var(--red); }
}
@keyframes scanline {
  0% { transform: translateY(-100%); }
  100% { transform: translateY(100vh); }
}
@keyframes glitch {
  0% { transform: translate(0); clip-path: inset(0 0 0 0); }
  5% { transform: translate(-4px,2px); clip-path: inset(10% 0 30% 0); filter:hue-rotate(90deg); }
  10% { transform: translate(4px,-2px); clip-path: inset(60% 0 5% 0); filter:hue-rotate(-90deg); }
  15% { transform: translate(-2px,4px); clip-path: inset(30% 0 60% 0); }
  20% { transform: translate(0); clip-path: inset(0 0 0 0); filter:none; }
  100% { transform: translate(0); clip-path: inset(0 0 0 0); }
}
@keyframes glitchText {
  0%,100% { text-shadow: 0 0 10px var(--neon), 0 0 30px var(--neon-glow); }
  5% { text-shadow: -3px 0 var(--red), 3px 0 #00aaff, 0 0 30px var(--neon-glow); }
  10% { text-shadow: 3px 0 var(--red), -3px 0 #00aaff, 0 0 30px var(--neon-glow); }
  15% { text-shadow: 0 0 10px var(--neon), 0 0 30px var(--neon-glow); }
}
@keyframes fadeInUp {
  from { opacity:0; transform:translateY(20px); }
  to { opacity:1; transform:translateY(0); }
}
@keyframes fadeIn { from{opacity:0} to{opacity:1} }
@keyframes slideInRight { from{transform:translateX(40px);opacity:0} to{transform:translateX(0);opacity:1} }
@keyframes typewriter { from{width:0} to{width:100%} }
@keyframes blink { 0%,50%{opacity:1} 51%,100%{opacity:0} }
@keyframes progressBar { from{width:0} to{width:100%} }
@keyframes shake {
  0%,100%{transform:translateX(0)}
  20%{transform:translateX(-8px)}
  40%{transform:translateX(8px)}
  60%{transform:translateX(-5px)}
  80%{transform:translateX(5px)}
}
@keyframes successPop {
  0%{transform:scale(0.5);opacity:0}
  60%{transform:scale(1.1);opacity:1}
  100%{transform:scale(1);opacity:1}
}
@keyframes timesUp {
  0%,100% { transform:scale(1) skewX(0); }
  25% { transform:scale(1.05) skewX(-5deg); filter:hue-rotate(90deg); }
  75% { transform:scale(0.95) skewX(5deg); filter:hue-rotate(-90deg); }
}
@keyframes scanFade {
  0%{opacity:0;transform:scale(0.95)}
  100%{opacity:1;transform:scale(1)}
}
@keyframes warningFlash {
  0%,100%{opacity:0} 50%{opacity:1}
}
@keyframes terminalBoot {
  0%{opacity:0;letter-spacing:20px}
  50%{opacity:1;letter-spacing:5px}
  100%{opacity:1;letter-spacing:2px}
}
@keyframes hexFloat {
  0%,100%{transform:translateY(0) rotate(0deg); opacity:0.15}
  50%{transform:translateY(-20px) rotate(180deg); opacity:0.35}
}
@keyframes loadingFill {
  from{width:0%}
  to{width:100%}
}

/* ===== LOADING SCREEN ===== */
.loading-screen { position:fixed; inset:0; background:var(--bg); z-index:1000; display:flex; flex-direction:column; align-items:center; justify-content:center; }
.loading-logo { font-family:'Orbitron',sans-serif; font-size:3.5rem; font-weight:900; color:var(--neon); animation:terminalBoot 1.5s ease-out forwards, glitchText 4s 2s infinite; letter-spacing:2px; }
.loading-subtitle { font-family:'Share Tech Mono',monospace; font-size:0.85rem; color:var(--text-dim); margin-top:8px; letter-spacing:8px; }
.loading-bar-container { width:400px; height:3px; background:rgba(0,255,136,0.1); border:1px solid rgba(0,255,136,0.2); margin-top:48px; border-radius:2px; overflow:hidden; }
.loading-bar-fill { height:100%; background:linear-gradient(90deg, var(--neon), #00aaff); box-shadow:0 0 15px var(--neon); animation:loadingFill 2.5s ease-in-out forwards; border-radius:2px; }
.loading-log { font-family:'Share Tech Mono',monospace; font-size:0.72rem; color:var(--text-dim); margin-top:24px; width:400px; }
.loading-log-line { animation:fadeInUp 0.3s ease forwards; opacity:0; }
.scanline-overlay { position:fixed; inset:0; pointer-events:none; z-index:9999; background:repeating-linear-gradient(0deg,transparent,transparent 2px,rgba(0,0,0,0.08) 2px,rgba(0,0,0,0.08) 4px); }
.scan-beam { position:fixed; left:0; right:0; height:2px; background:linear-gradient(90deg,transparent,rgba(0,255,136,0.4),transparent); animation:scanline 4s linear infinite; pointer-events:none; z-index:9998; }

/* ===== HEADER ===== */
.header { display:flex; align-items:center; justify-content:space-between; padding:10px 20px; border-bottom:1px solid var(--border); background:rgba(5,10,7,0.9); backdrop-filter:blur(10px); position:relative; z-index:10; height:54px; }
.header-logo { font-family:'Orbitron',sans-serif; font-weight:900; font-size:1.1rem; color:var(--neon); animation:glitchText 8s 3s infinite; letter-spacing:2px; }
.timer-display { font-family:'Orbitron',sans-serif; font-size:1.4rem; font-weight:700; padding:6px 18px; border-radius:4px; background:rgba(0,255,136,0.05); border:1px solid var(--border); transition:all 0.3s; }
.timer-display.urgent { color:var(--red) !important; border-color:var(--red) !important; animation:pulseBorderRed 0.8s ease-in-out infinite; text-shadow:0 0 15px var(--red); }
.progress-dots span { display:inline-block; width:8px; height:8px; border-radius:50%; background:var(--bg3); border:1px solid var(--border); margin:0 3px; transition:all 0.3s; }
.progress-dots span.done { background:var(--neon); box-shadow:0 0 8px var(--neon); }
.progress-dots span.current { background:transparent; border-color:var(--neon); animation:pulseBorder 1s infinite; }

/* ===== LAYOUT ===== */
.app-body { display:flex; height:calc(100vh - 54px); overflow:hidden; position:relative; z-index:5; }
.left-panel { width:42%; min-width:340px; border-right:1px solid var(--border); overflow-y:auto; padding:20px; background:rgba(5,10,7,0.6); display:flex; flex-direction:column; gap:14px; }
.right-panel { flex:1; display:flex; flex-direction:column; overflow:hidden; background:rgba(5,10,7,0.4); }

/* ===== DIFFICULTY BADGE ===== */
.badge { font-family:'Orbitron',sans-serif; font-size:0.65rem; font-weight:700; letter-spacing:2px; padding:3px 10px; border-radius:3px; display:inline-block; }
.badge-easy { color:#00ff88; background:rgba(0,255,136,0.1); border:1px solid rgba(0,255,136,0.4); }
.badge-medium { color:#ffaa00; background:rgba(255,170,0,0.1); border:1px solid rgba(255,170,0,0.4); }
.badge-hard { color:#ff4466; background:rgba(255,68,102,0.1); border:1px solid rgba(255,68,102,0.4); }
.badge-hard\+ { color:#ff2200; background:rgba(255,34,0,0.15); border:1px solid rgba(255,34,0,0.6); text-shadow:0 0 8px rgba(255,34,0,0.8); }
.badge-insane { color:#ff00ff; background:rgba(255,0,255,0.1); border:1px solid rgba(255,0,255,0.5); text-shadow:0 0 10px rgba(255,0,255,0.8); animation:pulseBorderRed 1.5s infinite; }

/* ===== CARDS ===== */
.panel-card { background:rgba(10,18,13,0.8); border:1px solid var(--border); border-radius:6px; padding:14px; animation:fadeInUp 0.4s ease; }
.panel-card h3 { font-family:'Share Tech Mono',monospace; font-size:0.7rem; color:var(--text-dim); letter-spacing:3px; text-transform:uppercase; margin-bottom:8px; padding-bottom:6px; border-bottom:1px solid rgba(0,255,136,0.1); }
.panel-title { font-family:'Orbitron',sans-serif; font-size:1.25rem; font-weight:700; color:var(--neon); animation:glitchText 10s 5s infinite; }
.problem-desc { font-size:0.82rem; line-height:1.7; color:var(--text); }

/* ===== CODE DISPLAY ===== */
.buggy-code { background:#0a0f0b; border:1px solid rgba(255,100,100,0.3); border-radius:4px; padding:14px; font-family:'JetBrains Mono',monospace; font-size:0.78rem; line-height:1.6; color:#ff9999; overflow-x:auto; white-space:pre; position:relative; }
.buggy-code::before { content:'// BUGGY CODE - FIX THIS'; display:block; color:rgba(255,100,100,0.5); font-size:0.65rem; letter-spacing:2px; margin-bottom:10px; }

/* ===== EXAMPLE BOX ===== */
.example-box { background:rgba(0,255,136,0.03); border:1px solid rgba(0,255,136,0.1); border-radius:4px; padding:10px; font-size:0.78rem; }
.example-label { color:var(--text-dim); font-size:0.68rem; letter-spacing:2px; margin-bottom:3px; }
.example-val { color:var(--neon); font-family:'Share Tech Mono',monospace; }

/* ===== EDITOR AREA ===== */
.editor-toolbar { display:flex; align-items:center; justify-content:space-between; padding:8px 14px; background:rgba(10,18,13,0.9); border-bottom:1px solid var(--border); }
.lang-selector { display:flex; gap:6px; }
.lang-btn { font-family:'Share Tech Mono',monospace; font-size:0.72rem; padding:4px 12px; border-radius:3px; border:1px solid var(--border); background:transparent; color:var(--text-dim); cursor:pointer; transition:all 0.2s; letter-spacing:1px; }
.lang-btn:hover { border-color:var(--neon); color:var(--neon); }
.lang-btn.active { border-color:var(--neon); color:var(--neon); background:rgba(0,255,136,0.08); box-shadow:0 0 8px var(--neon-glow); }
.editor-container { flex:1; overflow:hidden; position:relative; }
#monaco-container { width:100%; height:100%; }

/* ===== BOTTOM PANEL ===== */
.bottom-panel { height:200px; min-height:160px; border-top:1px solid var(--border); display:flex; flex-direction:column; background:rgba(5,10,7,0.8); }
.bottom-tabs { display:flex; border-bottom:1px solid var(--border); }
.btab { font-family:'Share Tech Mono',monospace; font-size:0.7rem; letter-spacing:2px; padding:7px 16px; border-right:1px solid var(--border); cursor:pointer; color:var(--text-dim); background:transparent; border-bottom:none; transition:all 0.2s; }
.btab.active { color:var(--neon); background:rgba(0,255,136,0.05); border-bottom:2px solid var(--neon); }
.btab:hover { color:var(--neon); }
.output-area { flex:1; padding:12px; font-family:'Share Tech Mono',monospace; font-size:0.76rem; overflow-y:auto; line-height:1.6; }
.output-prompt { color:var(--text-dim); }
.output-success { color:var(--neon); }
.output-error { color:#ff4466; }
.output-warn { color:#ffaa00; }
.custom-input { width:100%; background:rgba(0,255,136,0.03); border:1px solid var(--border); border-radius:3px; color:var(--text); font-family:'Share Tech Mono',monospace; font-size:0.76rem; padding:8px; resize:none; outline:none; height:80px; }
.custom-input:focus { border-color:var(--neon); box-shadow:0 0 8px var(--neon-glow); }

/* ===== BUTTONS ===== */
.action-bar { display:flex; align-items:center; gap:10px; padding:10px 14px; border-top:1px solid var(--border); background:rgba(5,10,7,0.9); }
.btn { font-family:'Orbitron',sans-serif; font-size:0.7rem; font-weight:700; letter-spacing:2px; padding:8px 20px; border-radius:4px; border:none; cursor:pointer; transition:all 0.2s; position:relative; overflow:hidden; }
.btn::after { content:''; position:absolute; inset:0; background:rgba(255,255,255,0.1); transform:scaleX(0); transform-origin:left; transition:transform 0.2s; }
.btn:hover::after { transform:scaleX(1); }
.btn-run { background:rgba(0,255,136,0.1); color:var(--neon); border:1px solid var(--neon); }
.btn-run:hover { background:rgba(0,255,136,0.2); box-shadow:0 0 15px var(--neon-glow); }
.btn-submit { background:var(--neon); color:#050a07; }
.btn-submit:hover { box-shadow:0 0 20px var(--neon), 0 0 40px var(--neon-glow); }
.btn:disabled { opacity:0.4; cursor:not-allowed; }
.btn-skip { background:transparent; color:var(--text-dim); border:1px solid rgba(255,255,255,0.1); font-size:0.65rem; padding:8px 14px; }
.btn-skip:hover { border-color:rgba(255,255,255,0.3); color:var(--text); }
.score-display { margin-left:auto; font-family:'Orbitron',sans-serif; font-size:0.8rem; color:var(--neon); }

/* ===== OVERLAYS ===== */
.overlay { position:fixed; inset:0; background:rgba(0,0,0,0.85); backdrop-filter:blur(8px); z-index:500; display:flex; align-items:center; justify-content:center; animation:fadeIn 0.3s ease; }
.modal { background:var(--bg2); border-radius:8px; padding:36px; max-width:500px; width:90%; animation:successPop 0.4s ease; }
.modal-success { border:1px solid var(--neon); box-shadow:0 0 40px var(--neon-glow), 0 0 80px rgba(0,255,136,0.1); }
.modal-fail { border:1px solid var(--red); box-shadow:0 0 40px var(--red-glow); animation:shake 0.4s ease; }

/* ===== TAB WARNING ===== */
.tab-warning { position:fixed; inset:0; background:rgba(255,34,68,0.15); backdrop-filter:blur(4px); z-index:800; display:flex; align-items:center; justify-content:center; animation:fadeIn 0.2s; }
.warning-box { background:var(--bg); border:2px solid var(--red); border-radius:6px; padding:32px; max-width:400px; text-align:center; box-shadow:0 0 60px var(--red-glow); animation:pulseBorderRed 1s infinite; }

/* ===== TIMES UP ===== */
.times-up { position:fixed; inset:0; background:rgba(0,0,0,0.9); z-index:600; display:flex; align-items:center; justify-content:center; flex-direction:column; animation:fadeIn 0.5s; }
.times-up-text { font-family:'Orbitron',sans-serif; font-size:5rem; font-weight:900; color:var(--red); animation:timesUp 0.3s ease infinite; text-shadow:0 0 40px var(--red), 0 0 80px var(--red-glow); letter-spacing:4px; }

/* ===== FINAL SCORE ===== */
.final-screen { position:fixed; inset:0; background:var(--bg); z-index:700; display:flex; align-items:center; justify-content:center; overflow:auto; animation:scanFade 0.8s ease; }
.final-card { max-width:600px; width:90%; text-align:center; padding:40px; }
.final-title { font-family:'Orbitron',sans-serif; font-size:2rem; font-weight:900; color:var(--neon); animation:glitchText 3s ease infinite; letter-spacing:3px; margin-bottom:8px; }
.score-circle { width:140px; height:140px; border-radius:50%; border:3px solid var(--neon); display:flex; align-items:center; justify-content:center; flex-direction:column; margin:24px auto; box-shadow:0 0 30px var(--neon-glow), inset 0 0 20px rgba(0,255,136,0.05); animation:pulseBorder 2s infinite; }
.score-num { font-family:'Orbitron',sans-serif; font-size:2.5rem; font-weight:900; color:var(--neon); }
.score-label { font-family:'Share Tech Mono',monospace; font-size:0.65rem; color:var(--text-dim); letter-spacing:3px; }
.stat-row { display:flex; justify-content:space-between; align-items:center; padding:10px 0; border-bottom:1px solid var(--border); font-size:0.82rem; }
.stat-key { color:var(--text-dim); font-family:'Share Tech Mono',monospace; letter-spacing:1px; }
.stat-val { color:var(--neon); font-family:'Orbitron',sans-serif; font-size:0.85rem; }
.hex-bg { position:absolute; inset:0; overflow:hidden; pointer-events:none; z-index:0; }
.hex { position:absolute; font-size:1.2rem; color:rgba(0,255,136,0.1); animation:hexFloat 6s ease-in-out infinite; font-family:'Share Tech Mono',monospace; }

/* ===== QUESTION NAV ===== */
.q-nav { display:flex; gap:6px; align-items:center; }
.q-num { width:26px; height:26px; border-radius:4px; display:flex; align-items:center; justify-content:center; font-family:'Orbitron',sans-serif; font-size:0.7rem; font-weight:700; cursor:pointer; transition:all 0.2s; border:1px solid var(--border); color:var(--text-dim); background:transparent; }
.q-num.active { border-color:var(--neon); color:var(--neon); background:rgba(0,255,136,0.08); box-shadow:0 0 8px var(--neon-glow); }
.q-num.solved { background:rgba(0,255,136,0.15); border-color:var(--neon); color:var(--neon); }
.q-num:hover { border-color:var(--neon); color:var(--neon); }

/* ===== HINTS ===== */
.hint-item { display:flex; align-items:center; gap:8px; font-size:0.78rem; color:var(--text-dim); padding:4px 0; }
.hint-item::before { content:'>>'; color:var(--neon); font-family:'Share Tech Mono',monospace; font-size:0.7rem; }

/* ===== CONSTRAINT CHIP ===== */
.constraint { display:inline-block; padding:2px 10px; border-radius:3px; background:rgba(0,255,136,0.05); border:1px solid rgba(0,255,136,0.15); font-family:'Share Tech Mono',monospace; font-size:0.72rem; color:var(--text-dim); margin:3px; }

/* ===== MISC ===== */
.terminal-cursor { display:inline-block; width:8px; height:14px; background:var(--neon); animation:blink 1s step-end infinite; vertical-align:middle; margin-left:3px; }
.disabled-overlay { position:absolute; inset:0; background:rgba(0,0,0,0.7); z-index:100; display:flex; align-items:center; justify-content:center; backdrop-filter:blur(4px); }
.points-flash { position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); font-family:'Orbitron',sans-serif; font-size:3rem; font-weight:900; color:var(--neon); text-shadow:0 0 30px var(--neon); animation:fadeInUp 0.5s ease forwards, fadeIn 0.3s 1.5s reverse forwards; pointer-events:none; z-index:900; }
</style>
</head>
<body>
<div class="scanline-overlay"></div>
<div class="scan-beam"></div>
<canvas id="matrix-canvas"></canvas>
<div id="root"></div>

<script>
var require = { paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs' } };
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/loader.min.js"></script>

<script type="text/babel">
const { useState, useEffect, useRef, useCallback } = React;
let isCodeModified = false;

// ===== MATRIX RAIN =====
(function initMatrix() {
  const canvas = document.getElementById('matrix-canvas');
  const ctx = canvas.getContext('2d');
  let cols, drops;
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789$#@!<>[]{}();=+-*/\\|?~^%&';
  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    cols = Math.floor(canvas.width / 16);
    drops = Array(cols).fill(1);
  }
  function draw() {
    ctx.fillStyle = 'rgba(5,10,7,0.05)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#00ff88';
    ctx.font = '14px Share Tech Mono, monospace';
    for (let i = 0; i < drops.length; i++) {
      const c = chars[Math.floor(Math.random() * chars.length)];
      ctx.globalAlpha = Math.random() * 0.5 + 0.1;
      ctx.fillText(c, i * 16, drops[i] * 16);
      if (drops[i] * 16 > canvas.height && Math.random() > 0.975) drops[i] = 0;
      drops[i]++;
    }
    ctx.globalAlpha = 1;
  }
  resize();
  window.addEventListener('resize', resize);
  setInterval(draw, 50);
})();

// ===== DISABLE RIGHT CLICK =====
document.addEventListener('contextmenu', e => e.preventDefault());

// ===== QUESTIONS DATA =====
const QUESTIONS = [
  {
    id: 1,
    title: "Binary Search Breach",
    difficulty: "EASY",
    points: 100,
    category: "Arrays",
    description: "The infiltration script is failing. Your binary search function enters an infinite loop and never terminates. The target value exists in the array but the algorithm can't locate it. Identify and neutralize the bugs to restore functionality.",
    constraints: ["1 ‚â§ arr.length ‚â§ 10‚Åµ", "Array is sorted ascending", "All elements are distinct"],
    examples: [
      { input: "arr=[1,3,5,7,9], target=5", output: "2 (index)" },
      { input: "arr=[2,4,6,8,10], target=2", output: "0 (index)" },
      { input: "arr=[1,2,3,4,5], target=9", output: "-1 (not found)" }
    ],
    hints: [
      "Check the initial value of 'right' ‚Äî should it be length or length-1?",
      "When moving left pointer, should it be mid or mid+1?",
      "The while condition is also wrong ‚Äî think about when left equals right"
    ],
    buggyCode: {
      javascript: `function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length; // BUG 1
  
  while (left < right) { // BUG 2
    let mid = Math.floor((left + right) / 2);
    
    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid; // BUG 3
    } else {
      right = mid - 1;
    }
  }
  
  return -1;
}`,
      python: `def binary_search(arr, target):
    left = 0
    right = len(arr)  # BUG 1
    
    while left < right:  # BUG 2
        mid = (left + right) // 2
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid  # BUG 3
        else:
            right = mid - 1
    
    return -1`,
      cpp: `int binarySearch(vector<int>& arr, int target) {
    int left = 0;
    int right = arr.size(); // BUG 1
    
    while (left < right) { // BUG 2
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) return mid;
        else if (arr[mid] < target) left = mid; // BUG 3
        else right = mid - 1;
    }
    return -1;
}`
    },
    testCode: {
      javascript: `
let passed = 0, failed = 0, errors = [];
function test(i1, i2, expected, label) {
  try {
    const result = binarySearch(i1, i2);
    if (result === expected) { passed++; }
    else { failed++; errors.push(\`‚ùå \${label}: got \${result}, expected \${expected}\`); }
  } catch(e) { failed++; errors.push(\`üí• \${label}: RUNTIME ERROR - \${e.message}\`); }
}
test([1,3,5,7,9], 5, 2, "Test 1");
test([2,4,6,8,10], 2, 0, "Test 2");
test([1,2,3,4,5], 9, -1, "Test 3");
test([7], 7, 0, "Test 4");
test([1,2,3,4,5,6,7,8,9,10], 10, 9, "Test 5");
if (failed === 0) { console.log("ALL_PASS:5/5 test cases passed"); }
else { errors.forEach(e => console.log(e)); console.log(\`PARTIAL:\${passed}/\${passed+failed} test cases passed\`); }`,
      python: `

def run_tests():
    cases = [
        ([1,3,5,7,9], 5, 2, "Test 1"),
        ([2,4,6,8,10], 2, 0, "Test 2"),
        ([1,2,3,4,5], 9, -1, "Test 3"),
        ([7], 7, 0, "Test 4"),
        ([1,2,3,4,5,6,7,8,9,10], 10, 9, "Test 5"),
    ]
    passed = 0; failed = 0
    for arr, target, expected, label in cases:
        try:
            result = binary_search(list(arr), target)
            if result == expected: passed += 1
            else: failed += 1; print(f"\u274c {label}: got {result}, expected {expected}")
        except Exception as e: failed += 1; print(f"\U0001f4a5 {label}: RUNTIME ERROR - {e}")
    if failed == 0: print(f"ALL_PASS:{passed}/{passed} test cases passed")
    else: print(f"PARTIAL:{passed}/{passed+failed} test cases passed")
run_tests()`,
      cpp: `

int main() {
    auto test = [](vector<int> arr, int target, int expected, string label) -> bool {
        int result = binarySearch(arr, target);
        if (result == expected) return true;
        cout << "\u274c " << label << ": got " << result << ", expected " << expected << "\n";
        return false;
    };
    int passed = 0, total = 5;
    passed += test({1,3,5,7,9}, 5, 2, "Test 1");
    passed += test({2,4,6,8,10}, 2, 0, "Test 2");
    passed += test({1,2,3,4,5}, 9, -1, "Test 3");
    passed += test({7}, 7, 0, "Test 4");
    passed += test({1,2,3,4,5,6,7,8,9,10}, 10, 9, "Test 5");
    if (passed == total) cout << "ALL_PASS:" << total << "/" << total << " test cases passed\n";
    else cout << "PARTIAL:" << passed << "/" << total << " test cases passed\n";
    return 0;
}`
    },

    testCases: [
      { label:'Test 1', input:[[1,3,5,7,9],5],   expected:'2',  wrongOutput:'-1' },
      { label:'Test 2', input:[[2,4,6,8,10],2],  expected:'0',  wrongOutput:'-1' },
      { label:'Test 3', input:[[1,2,3,4,5],9],   expected:'-1', wrongOutput:'undefined' },
      { label:'Test 4', input:[[7],7],            expected:'0',  wrongOutput:'-1' },
      { label:'Test 5', input:[[1,2,3,4,5,6,7,8,9,10],10], expected:'9', wrongOutput:'-1' },
    ],
    validator: `function binarySearch(arr,target){let l=0,r=arr.length-1;while(l<=r){let m=Math.floor((l+r)/2);if(arr[m]===target)return m;else if(arr[m]<target)l=m+1;else r=m-1;}return -1;}`,
    validatorRunner: `
      const cases=[[[1,3,5,7,9],5,2],[[2,4,6,8,10],2,0],[[1,2,3,4,5],9,-1],[[7],7,0],[[1,2,3,4,5,6,7,8,9,10],10,9]];
      let p=0,f=0;
      cases.forEach(([arr,t,exp],i)=>{const r=binarySearch([...arr],t);if(r===exp)p++;else{f++;console.log('‚ùå Test '+(i+1)+': got '+r+', expected '+exp);}});
      if(f===0)console.log('ALL_PASS:'+p+'/'+p+' test cases passed');
      else console.log('PARTIAL:'+p+'/'+(p+f)+' test cases passed');
    `,
    fixChecks: {
      python: [
        { pattern: /right\s*=\s*len\s*\(\s*arr\s*\)\s*-\s*1/, description: 'Fix BUG 1: right = len(arr) - 1' },
        { pattern: /while\s+left\s*<=\s*right/, description: 'Fix BUG 2: while left <= right' },
        { pattern: /left\s*=\s*mid\s*\+\s*1/, description: 'Fix BUG 3: left = mid + 1' },
      ],
      cpp: [
        { pattern: /right\s*=\s*arr\s*\.\s*size\s*\(\s*\)\s*-\s*1/, description: 'Fix BUG 1: right = arr.size() - 1' },
        { pattern: /while\s*\(\s*left\s*<=\s*right\s*\)/, description: 'Fix BUG 2: while (left <= right)' },
        { pattern: /left\s*=\s*mid\s*\+\s*1/, description: 'Fix BUG 3: left = mid + 1' },
      ],
    },
    solvedBy: false
  },
  {
    id: 2,
    title: "Palindrome Protocol",
    difficulty: "EASY",
    points: 100,
    category: "Strings",
    description: "The authentication system uses palindrome verification to validate access tokens. The function is reporting false negatives ‚Äî valid palindromes are being rejected. The character comparison logic has been corrupted. Fix the decryption protocol.",
    constraints: ["1 ‚â§ s.length ‚â§ 10‚Å¥", "String contains only lowercase letters", "Empty string is a palindrome"],
    examples: [
      { input: `s="racecar"`, output: "true" },
      { input: `s="hello"`, output: "false" },
      { input: `s="abcba"`, output: "true" }
    ],
    hints: [
      "Look at the loop termination condition ‚Äî does it cover all characters?",
      "The comparison indices might be targeting wrong positions",
      "Consider what happens at the exact middle of an odd-length string"
    ],
    buggyCode: {
      javascript: `function isPalindrome(s) {
  let left = 0;
  let right = s.length; // BUG 1
  
  while (left < right) {
    if (s[left] !== s[right]) { // BUG 2
      return false;
    }
    left++;
    right--; // BUG 3 (missing update makes it skip)
  }
  
  return true;
}`,
      python: `def is_palindrome(s):
    left = 0
    right = len(s)  # BUG 1
    
    while left < right:
        if s[left] != s[right]:  # BUG 2
            return False
        left += 1
        right -= 1
    
    return True`,
      cpp: `bool isPalindrome(string s) {
    int left = 0;
    int right = s.length(); // BUG 1
    
    while (left < right) {
        if (s[left] != s[right]) // BUG 2
            return false;
        left++;
        right--;
    }
    return true;
}`
    },
    testCode: {
      javascript: `
let passed = 0, failed = 0, errors = [];
function testP(input, expected, label) {
  try {
    const result = isPalindrome(input);
    if (result === expected) { passed++; }
    else { failed++; errors.push(\`‚ùå \${label}: got \${result}, expected \${expected}\`); }
  } catch(e) { failed++; errors.push(\`üí• \${label}: RUNTIME ERROR - \${e.message}\`); }
}
testP("racecar", true, "Test 1"); testP("hello", false, "Test 2");
testP("abcba", true, "Test 3"); testP("a", true, "Test 4");
testP("ab", false, "Test 5"); testP("aabbaa", true, "Test 6");
if (failed === 0) { console.log("ALL_PASS:6/6 test cases passed"); }
else { errors.forEach(e => console.log(e)); console.log(\`PARTIAL:\${passed}/\${passed+failed} test cases passed\`); }`,
      python: `

def run_tests():
    cases = [("racecar",True,"T1"),("hello",False,"T2"),("abcba",True,"T3"),("a",True,"T4"),("ab",False,"T5"),("aabbaa",True,"T6")]
    passed = 0; failed = 0
    for s, expected, label in cases:
        try:
            result = is_palindrome(s)
            if result == expected: passed += 1
            else: failed += 1; print(f"\u274c {label}: got {result}, expected {expected}")
        except Exception as e: failed += 1; print(f"\U0001f4a5 {label}: {e}")
    if failed == 0: print(f"ALL_PASS:{passed}/{passed} test cases passed")
    else: print(f"PARTIAL:{passed}/{passed+failed} test cases passed")
run_tests()`,
      cpp: `

int main() {
    auto test = [](string s, bool expected, string label) -> bool {
        bool result = isPalindrome(s);
        if (result == expected) return true;
        cout << "\u274c " << label << ": got " << result << ", expected " << expected << "\n";
        return false;
    };
    int passed = 0, total = 6;
    passed += test("racecar", true, "T1"); passed += test("hello", false, "T2");
    passed += test("abcba", true, "T3"); passed += test("a", true, "T4");
    passed += test("ab", false, "T5"); passed += test("aabbaa", true, "T6");
    if (passed == total) cout << "ALL_PASS:" << total << "/" << total << " test cases passed\n";
    else cout << "PARTIAL:" << passed << "/" << total << " test cases passed\n";
    return 0;
}`
    },

    testCases: [
      { label:'Test 1', input:['racecar'], expected:'true',  wrongOutput:'false' },
      { label:'Test 2', input:['hello'],   expected:'false', wrongOutput:'true'  },
      { label:'Test 3', input:['abcba'],   expected:'true',  wrongOutput:'false' },
      { label:'Test 4', input:['a'],       expected:'true',  wrongOutput:'false' },
      { label:'Test 5', input:['ab'],      expected:'false', wrongOutput:'true'  },
      { label:'Test 6', input:['aabbaa'],  expected:'true',  wrongOutput:'false' },
    ],
    validator: `function isPalindrome(s){let l=0,r=s.length-1;while(l<r){if(s[l]!==s[r])return false;l++;r--;}return true;}`,
    validatorRunner: `
      const cases=[['racecar',true],['hello',false],['abcba',true],['a',true],['ab',false],['aabbaa',true]];
      let p=0,f=0;
      cases.forEach(([s,exp],i)=>{const r=isPalindrome(s);if(r===exp)p++;else{f++;console.log('‚ùå Test '+(i+1)+': got '+r+', expected '+exp);}});
      if(f===0)console.log('ALL_PASS:'+p+'/'+p+' test cases passed');
      else console.log('PARTIAL:'+p+'/'+(p+f)+' test cases passed');
    `,
    fixChecks: {
      python: [
        { pattern: /right\s*=\s*len\s*\(\s*s\s*\)\s*-\s*1/, description: 'Fix BUG 1: right = len(s) - 1' },
        { pattern: /s\s*\[\s*left\s*\]\s*!=\s*s\s*\[\s*right\s*\]/, description: 'Fix BUG 2: s[left] != s[right]' },
      ],
      cpp: [
        { pattern: /right\s*=\s*s\s*\.\s*(length|size)\s*\(\s*\)\s*-\s*1/, description: 'Fix BUG 1: right = s.length() - 1' },
        { pattern: /s\s*\[\s*left\s*\]\s*!=\s*s\s*\[\s*right\s*\]/, description: 'Fix BUG 2: s[left] != s[right]' },
      ],
    },
    solvedBy: false
  },
  {
    id: 3,
    title: "Bubble Sort Backdoor",
    difficulty: "MEDIUM",
    points: 200,
    category: "Sorting",
    description: "Data packets are arriving unsorted, causing the firewall to malfunction. The sort algorithm has three critical bugs injected by a saboteur. The array is being processed incorrectly ‚Äî some elements refuse to swap and others are duplicated. Restore the sorting algorithm.",
    constraints: ["1 ‚â§ arr.length ‚â§ 10‚Å¥", "Elements can be negative", "Must sort in ascending order"],
    examples: [
      { input: "arr=[64,34,25,12,22,11,90]", output: "[11,12,22,25,34,64,90]" },
      { input: "arr=[5,1,4,2,8]", output: "[1,2,4,5,8]" },
      { input: "arr=[-3,1,-1,2,0]", output: "[-3,-1,0,1,2]" }
    ],
    hints: [
      "The outer loop bound is off ‚Äî check if 'n' should be 'n-1'",
      "The inner loop bound doesn't account for already-sorted elements",
      "The swap logic might have a wrong comparison operator"
    ],
    buggyCode: {
      javascript: `function bubbleSort(arr) {
  const n = arr.length;
  
  for (let i = 0; i < n; i++) { // BUG 1
    for (let j = 0; j < n; j++) { // BUG 2
      if (arr[j] > arr[j + 1]) { // BUG 3 (boundary)
        let temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
  
  return arr;
}`,
      python: `def bubble_sort(arr):
    n = len(arr)
    
    for i in range(n):  # BUG 1
        for j in range(n):  # BUG 2
            if arr[j] > arr[j + 1]:  # BUG 3 (boundary)
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    
    return arr`,
      cpp: `vector<int> bubbleSort(vector<int> arr) {
    int n = arr.size();
    
    for (int i = 0; i < n; i++) { // BUG 1
        for (int j = 0; j < n; j++) { // BUG 2
            if (arr[j] > arr[j + 1]) { // BUG 3
                swap(arr[j], arr[j + 1]);
            }
        }
    }
    return arr;
}`
    },
    testCode: {
      javascript: `
function arrEq(a, b) { return a.length===b.length && a.every((v,i)=>v===b[i]); }
let passed = 0, failed = 0, errors = [];
function testB(input, expected, label) {
  try {
    const result = bubbleSort([...input]);
    if (arrEq(result, expected)) { passed++; }
    else { failed++; errors.push(\`‚ùå \${label}: got [\${result}], expected [\${expected}]\`); }
  } catch(e) { failed++; errors.push(\`üí• \${label}: RUNTIME ERROR - \${e.message}\`); }
}
testB([64,34,25,12,22,11,90],[11,12,22,25,34,64,90],"T1");
testB([5,1,4,2,8],[1,2,4,5,8],"T2");
testB([-3,1,-1,2,0],[-3,-1,0,1,2],"T3");
testB([1],[1],"T4"); testB([3,3,1,1],[1,1,3,3],"T5");
if (failed === 0) { console.log("ALL_PASS:5/5 test cases passed"); }
else { errors.forEach(e => console.log(e)); console.log(\`PARTIAL:\${passed}/\${passed+failed} test cases passed\`); }`,
      python: `

def run_tests():
    cases = [
        ([64,34,25,12,22,11,90],[11,12,22,25,34,64,90],"T1"),
        ([5,1,4,2,8],[1,2,4,5,8],"T2"),
        ([-3,1,-1,2,0],[-3,-1,0,1,2],"T3"),
        ([1],[1],"T4"),
        ([3,3,1,1],[1,1,3,3],"T5"),
    ]
    passed = 0; failed = 0
    for inp, expected, label in cases:
        try:
            result = bubble_sort(list(inp))
            if result == expected: passed += 1
            else: failed += 1; print(f"\u274c {label}: got {result}, expected {expected}")
        except Exception as e: failed += 1; print(f"\U0001f4a5 {label}: {e}")
    if failed == 0: print(f"ALL_PASS:{passed}/{passed} test cases passed")
    else: print(f"PARTIAL:{passed}/{passed+failed} test cases passed")
run_tests()`,
      cpp: `

int main() {
    auto test = [](vector<int> arr, vector<int> expected, string label) -> bool {
        vector<int> result = bubbleSort(arr);
        if (result == expected) return true;
        cout << "\u274c " << label << ": wrong output\n";
        return false;
    };
    int passed = 0, total = 5;
    passed += test({64,34,25,12,22,11,90},{11,12,22,25,34,64,90},"T1");
    passed += test({5,1,4,2,8},{1,2,4,5,8},"T2");
    passed += test({-3,1,-1,2,0},{-3,-1,0,1,2},"T3");
    passed += test({1},{1},"T4");
    passed += test({3,3,1,1},{1,1,3,3},"T5");
    if (passed == total) cout << "ALL_PASS:" << total << "/" << total << " test cases passed\n";
    else cout << "PARTIAL:" << passed << "/" << total << " test cases passed\n";
    return 0;
}`
    },

    testCases: [
      { label:'Test 1', input:[[64,34,25,12,22,11,90]], expected:'[11,12,22,25,34,64,90]', wrongOutput:'[64,34,25,12,22,11,90]' },
      { label:'Test 2', input:[[5,1,4,2,8]],            expected:'[1,2,4,5,8]',            wrongOutput:'[5,1,4,2,8]' },
      { label:'Test 3', input:[[-3,1,-1,2,0]],           expected:'[-3,-1,0,1,2]',          wrongOutput:'[-3,1,-1,2,0]' },
      { label:'Test 4', input:[[1]],                     expected:'[1]',                    wrongOutput:'undefined' },
      { label:'Test 5', input:[[3,3,1,1]],               expected:'[1,1,3,3]',              wrongOutput:'[3,3,1,1]' },
    ],
    validator: `function bubbleSort(arr){const n=arr.length;for(let i=0;i<n-1;i++){for(let j=0;j<n-1-i;j++){if(arr[j]>arr[j+1]){let t=arr[j];arr[j]=arr[j+1];arr[j+1]=t;}}}return arr;}`,
    validatorRunner: `
      const cases=[[[64,34,25,12,22,11,90],[11,12,22,25,34,64,90]],[[5,1,4,2,8],[1,2,4,5,8]],[[-3,1,-1,2,0],[-3,-1,0,1,2]],[[1],[1]],[[3,3,1,1],[1,1,3,3]]];
      let p=0,f=0;
      cases.forEach(([arr,exp],i)=>{const r=bubbleSort([...arr]);const ok=r.length===exp.length&&r.every((v,j)=>v===exp[j]);if(ok)p++;else{f++;console.log('‚ùå Test '+(i+1)+': got ['+r+'], expected ['+exp+']');}});
      if(f===0)console.log('ALL_PASS:'+p+'/'+p+' test cases passed');
      else console.log('PARTIAL:'+p+'/'+(p+f)+' test cases passed');
    `,
    fixChecks: {
      python: [
        { pattern: /for\s+i\s+in\s+range\s*\(\s*n\s*-\s*1\s*\)/, description: 'Fix BUG 1: outer loop range(n-1)' },
        { pattern: /for\s+j\s+in\s+range\s*\(\s*n\s*-\s*1\s*-\s*i\s*\)/, description: 'Fix BUG 2: inner loop range(n-1-i)' },
        { pattern: /if\s+arr\s*\[\s*j\s*\]\s*>\s*arr\s*\[\s*j\s*\+\s*1\s*\]/, description: 'Fix BUG 3: correct comparison arr[j] > arr[j+1]' },
      ],
      cpp: [
        { pattern: /i\s*<\s*n\s*-\s*1/, description: 'Fix BUG 1: outer loop i < n-1' },
        { pattern: /j\s*<\s*n\s*-\s*1\s*-\s*i/, description: 'Fix BUG 2: inner loop j < n-1-i' },
        { pattern: /arr\s*\[\s*j\s*\]\s*>\s*arr\s*\[\s*j\s*\+\s*1\s*\]/, description: 'Fix BUG 3: correct comparison arr[j] > arr[j+1]' },
      ],
    },
    solvedBy: false
  },
  {
    id: 4,
    title: "Stack Overflow Exploit",
    difficulty: "MEDIUM",
    points: 200,
    category: "Stack",
    description: "The bracket validation firewall is broken ‚Äî it's allowing malformed code through the security scanner. The stack-based parentheses checker has logic errors that cause it to approve invalid expressions. Multiple bugs have been injected. Patch the vulnerability.",
    constraints: ["1 ‚â§ s.length ‚â§ 10‚Å¥", "String contains only ()[]{}","Empty string returns true"],
    examples: [
      { input: `s="()[]{}"`, output: "true" },
      { input: `s="([)]"`, output: "false" },
      { input: `s="{[]}"`, output: "true" }
    ],
    hints: [
      "Check what gets pushed to the stack for closing brackets",
      "The map lookup for closing brackets might have reversed key/value",
      "The final return condition might be inverted"
    ],
    buggyCode: {
      javascript: `function isValid(s) {
  const stack = [];
  const map = {
    ')': '(',
    ']': '[',
    '}': '{'
  };
  
  for (let char of s) {
    if (char === '(' || char === '[' || char === '{') {
      stack.push(char);
    } else {
      const top = stack.pop(); // BUG 1: should check if stack is empty
      if (top !== map[char]) { // BUG 2: map is inverted
        return true; // BUG 3: should return false
      }
    }
  }
  
  return stack.length > 0; // BUG 4: should be length === 0
}`,
      python: `def is_valid(s):
    stack = []
    mapping = {')': '(', ']': '[', '}': '{'}
    
    for char in s:
        if char in '([{':
            stack.append(char)
        else:
            if not stack:
                return False
            top = stack.pop()
            if top != mapping[char]:  # BUG: mapping is inverted
                return True  # BUG: should return False
    
    return len(stack) > 0  # BUG: should be == 0`,
      cpp: `bool isValid(string s) {
    stack<char> st;
    map<char,char> mp = {{')', '('}, {']', '['}, {'}', '{'}};
    
    for (char c : s) {
        if (c=='(' || c=='[' || c=='{') st.push(c);
        else {
            if (st.empty()) return false;
            char top = st.top(); st.pop();
            if (top != mp[c]) return true; // BUG
        }
    }
    return !st.empty(); // BUG
}`
    },
    testCode: {
      javascript: `
let passed = 0, failed = 0, errors = [];
function testV(input, expected, label) {
  try {
    const result = isValid(input);
    if (result === expected) { passed++; }
    else { failed++; errors.push(\`‚ùå \${label}: got \${result}, expected \${expected}\`); }
  } catch(e) { failed++; errors.push(\`üí• \${label}: RUNTIME ERROR - \${e.message}\`); }
}
testV("()[]{}", true, "T1"); testV("([)]", false, "T2"); testV("{[]}", true, "T3");
testV("(", false, "T4"); testV("", true, "T5"); testV("((()))", true, "T6"); testV("]", false, "T7");
if (failed === 0) { console.log("ALL_PASS:7/7 test cases passed"); }
else { errors.forEach(e => console.log(e)); console.log(\`PARTIAL:\${passed}/\${passed+failed} test cases passed\`); }`,
      python: `

def run_tests():
    cases = [("()[]{}", True,"T1"),("([)]",False,"T2"),("{[]}",True,"T3"),("(",False,"T4"),("",True,"T5"),("((()))",True,"T6"),("]",False,"T7")]
    passed = 0; failed = 0
    for s, expected, label in cases:
        try:
            result = is_valid(s)
            if result == expected: passed += 1
            else: failed += 1; print(f"\u274c {label}: got {result}, expected {expected}")
        except Exception as e: failed += 1; print(f"\U0001f4a5 {label}: {e}")
    if failed == 0: print(f"ALL_PASS:{passed}/{passed} test cases passed")
    else: print(f"PARTIAL:{passed}/{passed+failed} test cases passed")
run_tests()`,
      cpp: `

int main() {
    auto test = [](string s, bool expected, string label) -> bool {
        bool result = isValid(s);
        if (result == expected) return true;
        cout << "\u274c " << label << ": got " << result << ", expected " << expected << "\n";
        return false;
    };
    int passed = 0, total = 7;
    passed += test("()[]{}", true, "T1"); passed += test("([)]", false, "T2");
    passed += test("{[]}", true, "T3"); passed += test("(", false, "T4");
    passed += test("", true, "T5"); passed += test("((()))", true, "T6");
    passed += test("]", false, "T7");
    if (passed == total) cout << "ALL_PASS:" << total << "/" << total << " test cases passed\n";
    else cout << "PARTIAL:" << passed << "/" << total << " test cases passed\n";
    return 0;
}`
    },

    testCases: [
      { label:'Test 1', input:['()[]{}'],  expected:'true',  wrongOutput:'false' },
      { label:'Test 2', input:['([)]'],    expected:'false', wrongOutput:'true'  },
      { label:'Test 3', input:['{[]}'],    expected:'true',  wrongOutput:'false' },
      { label:'Test 4', input:['('],       expected:'false', wrongOutput:'true'  },
      { label:'Test 5', input:[''],        expected:'true',  wrongOutput:'false' },
      { label:'Test 6', input:['((()))'],  expected:'true',  wrongOutput:'false' },
      { label:'Test 7', input:[']'],       expected:'false', wrongOutput:'true'  },
    ],
    validator: `function isValid(s){const st=[],m={')':'(',']':'[','}':'{'};for(const c of s){if('([{'.includes(c))st.push(c);else{if(!st.length||st[st.length-1]!==m[c])return false;st.pop();}}return st.length===0;}`,
    validatorRunner: `
      const cases=[['()[]{}'  ,true],['([)]',false],['{[]}',true],['(',false],['',true],['((()))',true],[']',false]];
      let p=0,f=0;
      cases.forEach(([s,exp],i)=>{const r=isValid(s);if(r===exp)p++;else{f++;console.log('‚ùå Test '+(i+1)+': got '+r+', expected '+exp);}});
      if(f===0)console.log('ALL_PASS:'+p+'/'+p+' test cases passed');
      else console.log('PARTIAL:'+p+'/'+(p+f)+' test cases passed');
    `,
    fixChecks: {
      python: [
        { pattern: /if\s+(not\s+stack|len\s*\(\s*stack\s*\)\s*==\s*0)/, description: 'Fix BUG 1: check if stack is empty before pop' },
        { pattern: /return\s+False/, description: 'Fix BUG 2 & 3: return False on mismatch (not True)' },
        { pattern: /return\s+len\s*\(\s*stack\s*\)\s*==\s*0/, description: 'Fix BUG 4: return len(stack) == 0' },
      ],
      cpp: [
        { pattern: /if\s*\(\s*st\s*\.\s*empty\s*\(\s*\)\s*\)/, description: 'Fix BUG 1: check stack empty' },
        { pattern: /return\s+false/, description: 'Fix BUG 2: return false on mismatch' },
        { pattern: /return\s+st\s*\.\s*empty\s*\(\s*\)/, description: 'Fix BUG 3: return st.empty()' },
      ],
    },
    solvedBy: false
  },
  {
    id: 5,
    title: "Hash Map Heist",
    difficulty: "HARD",
    points: 300,
    category: "Hash Map",
    description: "CRITICAL BREACH. The two-sum encryption module is malfunctioning ‚Äî it's returning wrong indices and causing decryption failures. Three bugs were planted by an insider threat. The hash map lookups are corrupted. This is your final challenge. Fix the algorithm before the system goes dark.",
    constraints: ["2 ‚â§ nums.length ‚â§ 10‚Å¥", "Exactly one solution exists","Cannot use same element twice"],
    examples: [
      { input: "nums=[2,7,11,15], target=9", output: "[0,1]" },
      { input: "nums=[3,2,4], target=6", output: "[1,2]" },
      { input: "nums=[3,3], target=6", output: "[0,1]" }
    ],
    hints: [
      "Check what is stored in the map ‚Äî should it be value‚Üíindex or index‚Üívalue?",
      "The complement calculation might have an operator error",
      "The order of checking vs inserting into the map matters"
    ],
    buggyCode: {
      javascript: `function twoSum(nums, target) {
  const map = {}; // stores index -> value (BUG 1: should be value -> index)
  
  for (let i = 0; i < nums.length; i++) {
    map[i] = nums[i]; // BUG 1
  }
  
  for (let i = 0; i < nums.length; i++) {
    const complement = target + nums[i]; // BUG 2: should be target - nums[i]
    
    if (map[complement] !== undefined && map[complement] !== i) { // BUG 3: wrong lookup
      return [i, map[complement]];
    }
  }
  
  return [];
}`,
      python: `def two_sum(nums, target):
    num_map = {}  # stores index -> value (BUG 1)
    
    for i, num in enumerate(nums):
        num_map[i] = num  # BUG 1: should be num_map[num] = i
    
    for i, num in enumerate(nums):
        complement = target + num  # BUG 2: should be target - num
        
        if complement in num_map and num_map[complement] != i:  # BUG 3
            return [i, num_map[complement]]
    
    return []`,
      cpp: `vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int,int> mp;
    
    for (int i = 0; i < nums.size(); i++)
        mp[i] = nums[i]; // BUG 1: should be mp[nums[i]] = i
    
    for (int i = 0; i < nums.size(); i++) {
        int complement = target + nums[i]; // BUG 2
        if (mp.count(complement) && mp[complement] != i) // BUG 3
            return {i, mp[complement]};
    }
    return {};
}`
    },
    testCode: {
      javascript: `
function arrEqTS(a,b){return a.length===b.length&&[...a].sort().join()===([...b]).sort().join();}
let passed = 0, failed = 0, errors = [];
function testTS(nums, target, expected, label) {
  try {
    const result = twoSum([...nums], target);
    if (arrEqTS(result, expected)) { passed++; }
    else { failed++; errors.push(\`‚ùå \${label}: got [\${result}], expected [\${expected}]\`); }
  } catch(e) { failed++; errors.push(\`üí• \${label}: RUNTIME ERROR - \${e.message}\`); }
}
testTS([2,7,11,15],9,[0,1],"T1"); testTS([3,2,4],6,[1,2],"T2");
testTS([3,3],6,[0,1],"T3"); testTS([1,5,3,7],8,[1,3],"T4"); testTS([0,4,3,0],0,[0,3],"T5");
if (failed === 0) { console.log("ALL_PASS:5/5 test cases passed"); }
else { errors.forEach(e => console.log(e)); console.log(\`PARTIAL:\${passed}/\${passed+failed} test cases passed\`); }`,
      python: `

def run_tests():
    cases = [
        ([2,7,11,15],9,[0,1],"T1"),([3,2,4],6,[1,2],"T2"),
        ([3,3],6,[0,1],"T3"),([1,5,3,7],8,[1,3],"T4"),([0,4,3,0],0,[0,3],"T5")
    ]
    passed = 0; failed = 0
    for nums, target, expected, label in cases:
        try:
            result = sorted(two_sum(list(nums), target))
            if result == sorted(expected): passed += 1
            else: failed += 1; print(f"\u274c {label}: got {result}, expected {expected}")
        except Exception as e: failed += 1; print(f"\U0001f4a5 {label}: {e}")
    if failed == 0: print(f"ALL_PASS:{passed}/{passed} test cases passed")
    else: print(f"PARTIAL:{passed}/{passed+failed} test cases passed")
run_tests()`,
      cpp: `

int main() {
    auto cmp = [](vector<int> a, vector<int> b){ sort(a.begin(),a.end()); sort(b.begin(),b.end()); return a==b; };
    auto test = [&](vector<int> nums, int target, vector<int> expected, string label) -> bool {
        vector<int> result = twoSum(nums, target);
        if (cmp(result, expected)) return true;
        cout << "\u274c " << label << ": wrong output\n";
        return false;
    };
    int passed = 0, total = 5;
    passed += test({2,7,11,15},9,{0,1},"T1"); passed += test({3,2,4},6,{1,2},"T2");
    passed += test({3,3},6,{0,1},"T3"); passed += test({1,5,3,7},8,{1,3},"T4");
    passed += test({0,4,3,0},0,{0,3},"T5");
    if (passed == total) cout << "ALL_PASS:" << total << "/" << total << " test cases passed\n";
    else cout << "PARTIAL:" << passed << "/" << total << " test cases passed\n";
    return 0;
}`
    },

    testCases: [
      { label:'Test 1', input:[[2,7,11,15],9],  expected:'[0,1]', wrongOutput:'[]' },
      { label:'Test 2', input:[[3,2,4],6],       expected:'[1,2]', wrongOutput:'[]' },
      { label:'Test 3', input:[[3,3],6],         expected:'[0,1]', wrongOutput:'[]' },
      { label:'Test 4', input:[[1,5,3,7],8],     expected:'[1,3]', wrongOutput:'[]' },
      { label:'Test 5', input:[[0,4,3,0],0],     expected:'[0,3]', wrongOutput:'[]' },
    ],
    validator: `function twoSum(nums,target){const m={};for(let i=0;i<nums.length;i++){const c=target-nums[i];if(m[c]!==undefined)return[m[c],i];m[nums[i]]=i;}return[];}`,
    validatorRunner: `
      const eq=(a,b)=>a.length===b.length&&[...a].sort().join()===[...b].sort().join();
      const cases=[[[2,7,11,15],9,[0,1]],[[3,2,4],6,[1,2]],[[3,3],6,[0,1]],[[1,5,3,7],8,[1,3]],[[0,4,3,0],0,[0,3]]];
      let p=0,f=0;
      cases.forEach(([nums,t,exp],i)=>{const r=twoSum([...nums],t);if(eq(r,exp))p++;else{f++;console.log('‚ùå Test '+(i+1)+': got ['+r+'], expected ['+exp+']');}});
      if(f===0)console.log('ALL_PASS:'+p+'/'+p+' test cases passed');
      else console.log('PARTIAL:'+p+'/'+(p+f)+' test cases passed');
    `,
    fixChecks: {
      python: [
        { pattern: /num_map\s*\[\s*num\s*\]\s*=\s*i/, description: 'Fix BUG 1: store num_map[num] = i' },
        { pattern: /complement\s*=\s*target\s*-\s*num/, description: 'Fix BUG 2: complement = target - num' },
        { pattern: /if\s+complement\s+in\s+num_map/, description: 'Fix BUG 3: look up complement in num_map' },
      ],
      cpp: [
        { pattern: /mp\s*\[\s*nums\s*\[\s*i\s*\]\s*\]\s*=\s*i/, description: 'Fix BUG 1: store mp[nums[i]] = i' },
        { pattern: /complement\s*=\s*target\s*-\s*nums\s*\[\s*i\s*\]/, description: 'Fix BUG 2: complement = target - nums[i]' },
        { pattern: /mp\s*\.count\s*\(\s*complement\s*\)/, description: 'Fix BUG 3: look up complement in map' },
      ],
    },
    solvedBy: false
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // Q6 ‚Äî CYCLE DETECTION INTRUSION (HARD)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    id: 6,
    title: "Cycle Detection Intrusion",
    difficulty: "HARD",
    points: 350,
    category: "Linked List",
    description: "ALERT: A rogue process has injected a cycle into the network packet chain. Your Floyd's Cycle Detection scanner (Tortoise & Hare) is broken ‚Äî the fast pointer moves wrong, a null check is missing causing instant crash, and the algorithm loops forever on valid inputs. The intrusion goes undetected. Fix all three bugs before the network collapses.",
    constraints: ["0 ‚â§ nodes ‚â§ 10‚Å¥", "Node values can be any integer", "-1 means no cycle (pos = -1)"],
    examples: [
      { input: "head=[3,2,0,-4], pos=1", output: "true (cycle at node 1)" },
      { input: "head=[1,2], pos=0",       output: "true (cycle at node 0)" },
      { input: "head=[1], pos=-1",        output: "false (no cycle)" }
    ],
    hints: [
      "Fast pointer should advance by 2 steps, not 1 ‚Äî it currently moves the same as slow",
      "Missing null check: what if head or head.next is null before the loop?",
      "The loop condition needs to guard fast AND fast.next against null"
    ],
    buggyCode: {
      javascript: `function hasCycle(head) {
  // BUG 1: no null guard ‚Äî crashes on empty list
  let slow = head;
  let fast = head;
  
  while (fast !== null && fast.next !== null) {
    slow = slow.next;
    fast = fast.next; // BUG 2: should be fast.next.next
    
    if (slow === fast) {
      return true;
    }
  }
  
  return false; // BUG 3: actually correct ‚Äî but BUG 2 makes this unreachable for cycles
}`,
      python: `def has_cycle(head):
    # BUG 1: no null guard
    slow = head
    fast = head
    
    while fast is not None and fast.next is not None:
        slow = slow.next
        fast = fast.next  # BUG 2: should be fast.next.next
        
        if slow is fast:
            return True
    
    return False`,
      cpp: `bool hasCycle(ListNode *head) {
    // BUG 1: no null guard
    ListNode *slow = head;
    ListNode *fast = head;
    
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next; // BUG 2: should be fast->next->next
        
        if (slow == fast) return true;
    }
    
    return false;
}`,
      java: `public boolean hasCycle(ListNode head) {
    // BUG 1: no null guard
    ListNode slow = head;
    ListNode fast = head;
    
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next; // BUG 2: should be fast.next.next
        
        if (slow == fast) return true;
    }
    
    return false;
}`,
      c: `bool hasCycle(struct ListNode *head) {
    // BUG 1: no null guard
    struct ListNode *slow = head;
    struct ListNode *fast = head;
    
    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;
        fast = fast->next; /* BUG 2: should be fast->next->next */
        
        if (slow == fast) return true;
    }
    
    return false;
}`
    },
    testCode: {
      javascript: `
// Node builder
function buildList(vals, pos) {
  if (!vals.length) return null;
  const nodes = vals.map(v => ({ val: v, next: null }));
  for (let i = 0; i < nodes.length - 1; i++) nodes[i].next = nodes[i+1];
  if (pos >= 0) nodes[nodes.length-1].next = nodes[pos];
  return nodes[0];
}
let p=0,f=0;
function testC(vals,pos,exp,label){
  try{
    const r=hasCycle(buildList(vals,pos));
    if(r===exp){p++;}
    else{f++;console.log('‚ùå '+label+': got '+r+', expected '+exp);}
  }catch(e){f++;console.log('üí• '+label+': '+e.message);}
}
testC([3,2,0,-4],1,true,'Test 1');
testC([1,2],0,true,'Test 2');
testC([1],-1,false,'Test 3');
testC([],-1,false,'Test 4');
testC([1,2,3,4,5],2,true,'Test 5');
if(f===0)console.log('ALL_PASS:'+p+'/'+p+' test cases passed');
else console.log('PARTIAL:'+p+'/'+(p+f)+' test cases passed');`
    },
    testCases: [
      { label:'Test 1', input:[[3,2,0,-4],1],  expected:'true',  wrongOutput:'false' },
      { label:'Test 2', input:[[1,2],0],        expected:'true',  wrongOutput:'false' },
      { label:'Test 3', input:[[1],-1],         expected:'false', wrongOutput:'true'  },
      { label:'Test 4', input:[[],  -1],        expected:'false', wrongOutput:'crash' },
      { label:'Test 5', input:[[1,2,3,4,5],2],  expected:'true',  wrongOutput:'false' },
    ],
    validator: `
function buildList(vals,pos){if(!vals.length)return null;const nodes=vals.map(v=>({val:v,next:null}));for(let i=0;i<nodes.length-1;i++)nodes[i].next=nodes[i+1];if(pos>=0)nodes[nodes.length-1].next=nodes[pos];return nodes[0];}
function hasCycle(head){if(!head)return false;let s=head,f=head;while(f&&f.next){s=s.next;f=f.next.next;if(s===f)return true;}return false;}`,
    validatorRunner: `
const cases=[[[3,2,0,-4],1,true],[[1,2],0,true],[[1],-1,false],[[],  -1,false],[[1,2,3,4,5],2,true]];
let p=0,f=0;
cases.forEach(([v,pos,exp],i)=>{const r=hasCycle(buildList(v,pos));if(r===exp)p++;else{f++;console.log('‚ùå Test '+(i+1)+': got '+r+', expected '+exp);}});
if(f===0)console.log('ALL_PASS:'+p+'/'+p+' test cases passed');
else console.log('PARTIAL:'+p+'/'+(p+f)+' test cases passed');`,
    fixChecks: {
      python: [
        { pattern: /if\s+(head\s+is\s+None|not\s+head)/, description: 'Fix BUG 1: null guard ‚Äî if not head: return False' },
        { pattern: /fast\s*=\s*fast\s*\.\s*next\s*\.\s*next/, description: 'Fix BUG 2: fast = fast.next.next (two hops)' },
      ],
      cpp: [
        { pattern: /if\s*\(\s*(head\s*==\s*nullptr|!head)\s*\)/, description: 'Fix BUG 1: null guard before loop' },
        { pattern: /fast\s*=\s*fast\s*->\s*next\s*->\s*next/, description: 'Fix BUG 2: fast = fast->next->next' },
      ],
      java: [
        { pattern: /if\s*\(\s*head\s*==\s*null\s*\)/, description: 'Fix BUG 1: null guard ‚Äî if (head == null) return false' },
        { pattern: /fast\s*=\s*fast\s*\.\s*next\s*\.\s*next/, description: 'Fix BUG 2: fast = fast.next.next' },
      ],
      c: [
        { pattern: /if\s*\(\s*(head\s*==\s*NULL|!head)\s*\)/, description: 'Fix BUG 1: null guard ‚Äî if (!head) return false' },
        { pattern: /fast\s*=\s*fast\s*->\s*next\s*->\s*next/, description: 'Fix BUG 2: fast = fast->next->next' },
      ],
    },
    solvedBy: false
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // Q7 ‚Äî LRU CACHE CORRUPTION (HARD+)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    id: 7,
    title: "LRU Cache Corruption",
    difficulty: "HARD+",
    points: 400,
    category: "Design",
    description: "CRITICAL SYSTEM FAILURE. The LRU Cache powering our identity broker is corrupted. The eviction policy is broken ‚Äî wrong capacity logic accepts one extra entry, nodes aren't removed from their current position before being promoted (causing dangling pointers), and memory leaks when evicting. Three planted bugs have turned our cache into a ghost machine. Restore it.",
    constraints: ["1 ‚â§ capacity ‚â§ 3000", "0 ‚â§ key, value ‚â§ 10‚Å¥", "get/put called up to 2√ó10‚Åµ times"],
    examples: [
      { input: 'LRUCache(2): put(1,1), put(2,2), get(1)', output: '1' },
      { input: 'put(3,3) ‚Üí evicts key 2',                 output: 'get(2) = -1' },
      { input: 'put(4,4) ‚Üí evicts key 1',                 output: 'get(1) = -1, get(3)=3, get(4)=4' }
    ],
    hints: [
      "Capacity check uses > instead of >= ‚Äî it allows one extra item before evicting",
      "On put/get, the node must be REMOVED from its current position before being moved to front",
      "The evict logic removes the tail but forgets to delete it from the map"
    ],
    buggyCode: {
      javascript: `class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.map = new Map();
    this.head = { key: 0, val: 0, prev: null, next: null };
    this.tail = { key: 0, val: 0, prev: null, next: null };
    this.head.next = this.tail;
    this.tail.prev = this.head;
  }
  
  _remove(node) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
  }
  
  _addToFront(node) {
    // BUG 2: should call _remove(node) first when re-inserting existing node
    node.next = this.head.next;
    node.prev = this.head;
    this.head.next.prev = node;
    this.head.next = node;
  }
  
  get(key) {
    if (!this.map.has(key)) return -1;
    const node = this.map.get(key);
    this._remove(node);
    this._addToFront(node);
    return node.val;
  }
  
  put(key, value) {
    if (this.map.has(key)) {
      const node = this.map.get(key);
      node.val = value;
      this._remove(node);
      this._addToFront(node);
    } else {
      const node = { key, val: value, prev: null, next: null };
      this.map.set(key, node);
      this._addToFront(node);
      if (this.map.size > this.capacity + 1) { // BUG 1: should be > capacity
        const lru = this.tail.prev;
        this._remove(lru);
        // BUG 3: map.delete(lru.key) is missing ‚Äî memory leak!
      }
    }
  }
}`,
      python: `class LRUCache:
    class Node:
        def __init__(self, key=0, val=0):
            self.key = key
            self.val = val
            self.prev = None
            self.next = None

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}
        self.head = self.Node()
        self.tail = self.Node()
        self.head.next = self.tail
        self.tail.prev = self.head

    def _remove(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev

    def _add_to_front(self, node):
        # BUG 2: should call self._remove(node) first for existing nodes
        node.next = self.head.next
        node.prev = self.head
        self.head.next.prev = node
        self.head.next = node

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        node = self.cache[key]
        self._remove(node)
        self._add_to_front(node)
        return node.val

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            node = self.cache[key]
            node.val = value
            self._remove(node)
            self._add_to_front(node)
        else:
            node = self.Node(key, value)
            self.cache[key] = node
            self._add_to_front(node)
            if len(self.cache) > self.capacity + 1:  # BUG 1: should be > self.capacity
                lru = self.tail.prev
                self._remove(lru)
                # BUG 3: del self.cache[lru.key] is missing`,
      cpp: `class LRUCache {
    int cap;
    list<pair<int,int>> dll;
    unordered_map<int, list<pair<int,int>>::iterator> mp;
public:
    LRUCache(int capacity) : cap(capacity) {}
    
    int get(int key) {
        if (!mp.count(key)) return -1;
        auto it = mp[key];
        dll.splice(dll.begin(), dll, it); // move to front
        return it->second;
    }
    
    void put(int key, int value) {
        if (mp.count(key)) {
            mp[key]->second = value;
            dll.splice(dll.begin(), dll, mp[key]);
        } else {
            dll.push_front({key, value});
            mp[key] = dll.begin();
            if ((int)dll.size() > cap + 1) { // BUG 1: should be > cap
                auto lru = dll.back();
                // BUG 3: mp.erase(lru.first) is missing
                dll.pop_back(); // BUG 2: pop before erase loses the key
            }
        }
    }
};`,
      java: `class LRUCache {
    private int capacity;
    private Map<Integer, Node> map;
    private Node head, tail;
    
    class Node {
        int key, val;
        Node prev, next;
        Node(int k, int v) { key=k; val=v; }
    }
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
        map = new HashMap<>();
        head = new Node(0,0);
        tail = new Node(0,0);
        head.next = tail;
        tail.prev = head;
    }
    
    private void remove(Node n) {
        n.prev.next = n.next;
        n.next.prev = n.prev;
    }
    
    private void addFront(Node n) {
        // BUG 2: must call remove(n) first for existing nodes
        n.next = head.next;
        n.prev = head;
        head.next.prev = n;
        head.next = n;
    }
    
    public int get(int key) {
        if (!map.containsKey(key)) return -1;
        Node n = map.get(key);
        remove(n); addFront(n);
        return n.val;
    }
    
    public void put(int key, int value) {
        if (map.containsKey(key)) {
            Node n = map.get(key);
            n.val = value;
            remove(n); addFront(n);
        } else {
            Node n = new Node(key, value);
            map.put(key, n);
            addFront(n);
            if (map.size() > capacity + 1) { // BUG 1: should be > capacity
                Node lru = tail.prev;
                remove(lru);
                // BUG 3: map.remove(lru.key) is missing
            }
        }
    }
}`,
      c: `typedef struct Node {
    int key, val;
    struct Node *prev, *next;
} Node;

typedef struct {
    int capacity, size;
    Node *head, *tail;
    // (simplified: no hashmap in C demo ‚Äî using linear scan)
} LRUCache;

LRUCache* lRUCacheCreate(int capacity) {
    LRUCache* c = malloc(sizeof(LRUCache));
    c->capacity = capacity; c->size = 0;
    c->head = malloc(sizeof(Node)); c->tail = malloc(sizeof(Node));
    c->head->prev=NULL; c->head->next=c->tail;
    c->tail->prev=c->head; c->tail->next=NULL;
    return c;
}

void removeNode(Node* n) {
    n->prev->next = n->next;
    n->next->prev = n->prev;
}

void addFront(LRUCache* c, Node* n) {
    /* BUG 2: should removeNode(n) first for existing nodes */
    n->next = c->head->next;
    n->prev = c->head;
    c->head->next->prev = n;
    c->head->next = n;
}

int lRUCacheGet(LRUCache* c, int key) {
    Node* cur = c->head->next;
    while (cur != c->tail) {
        if (cur->key == key) {
            removeNode(cur); addFront(c, cur);
            return cur->val;
        }
        cur = cur->next;
    }
    return -1;
}

void lRUCachePut(LRUCache* c, int key, int value) {
    Node* cur = c->head->next;
    while (cur != c->tail) {
        if (cur->key == key) {
            cur->val = value;
            removeNode(cur); addFront(c, cur);
            return;
        }
        cur = cur->next;
    }
    Node* n = malloc(sizeof(Node));
    n->key=key; n->val=value;
    addFront(c, n);
    c->size++;
    if (c->size > c->capacity + 1) { /* BUG 1: should be > c->capacity */
        Node* lru = c->tail->prev;
        removeNode(lru);
        /* BUG 3: free(lru) is missing ‚Äî memory leak */
        c->size--;
    }
}`
    },
    testCode: {
      javascript: `
class LRUCacheRef {
  constructor(cap){this.cap=cap;this.map=new Map();this.h={};this.t={};this.h.next=this.t;this.t.prev=this.h;}
  _rm(n){n.prev.next=n.next;n.next.prev=n.prev;}
  _af(n){n.next=this.h.next;n.prev=this.h;this.h.next.prev=n;this.h.next=n;}
  get(k){if(!this.map.has(k))return -1;const n=this.map.get(k);this._rm(n);this._af(n);return n.v;}
  put(k,v){if(this.map.has(k)){const n=this.map.get(k);n.v=v;this._rm(n);this._af(n);}else{const n={k,v};this.map.set(k,n);this._af(n);if(this.map.size>this.cap){const l=this.t.prev;this._rm(l);this.map.delete(l.k);}}}
}
let p=0,f=0;
function run(cap, ops) {
  const c=new LRUCacheRef(cap);
  return ops.map(([op,...a])=>op==='put'?(c.put(a[0],a[1]),null):c.get(a[0]));
}
// Test 1
const r1=run(2,[['put',1,1],['put',2,2],['get',1],['put',3,3],['get',2],['get',1],['get',3]]);
const e1=[null,null,1,null,-1,1,3];
if(JSON.stringify(r1)===JSON.stringify(e1))p++;else{f++;console.log('‚ùå Test 1: got '+JSON.stringify(r1)+' expected '+JSON.stringify(e1));}
// Test 2
const r2=run(2,[['put',1,1],['put',2,2],['put',3,3],['get',1]]);
const e2=[null,null,null,-1];
if(JSON.stringify(r2)===JSON.stringify(e2))p++;else{f++;console.log('‚ùå Test 2: got '+JSON.stringify(r2)+' expected '+JSON.stringify(e2));}
// Test 3
const r3=run(1,[['put',2,1],['get',2],['put',3,2],['get',2],['get',3]]);
const e3=[null,1,null,-1,2];
if(JSON.stringify(r3)===JSON.stringify(e3))p++;else{f++;console.log('‚ùå Test 3: got '+JSON.stringify(r3)+' expected '+JSON.stringify(e3));}
if(f===0)console.log('ALL_PASS:'+p+'/'+p+' test cases passed');
else console.log('PARTIAL:'+p+'/'+(p+f)+' test cases passed');`
    },
    testCases: [
      { label:'Test 1', input:['cap=2,ops=standard'],  expected:'[_,_,1,_,-1,1,3]',  wrongOutput:'wrong' },
      { label:'Test 2', input:['cap=2,evict first'],    expected:'[_,_,_,-1]',         wrongOutput:'wrong' },
      { label:'Test 3', input:['cap=1,single slot'],    expected:'[_,1,_,-1,2]',       wrongOutput:'wrong' },
    ],
    validator: `
class LRUCacheRef{constructor(cap){this.cap=cap;this.map=new Map();this.h={};this.t={};this.h.next=this.t;this.t.prev=this.h;}_rm(n){n.prev.next=n.next;n.next.prev=n.prev;}_af(n){n.next=this.h.next;n.prev=this.h;this.h.next.prev=n;this.h.next=n;}get(k){if(!this.map.has(k))return -1;const n=this.map.get(k);this._rm(n);this._af(n);return n.v;}put(k,v){if(this.map.has(k)){const n=this.map.get(k);n.v=v;this._rm(n);this._af(n);}else{const n={k,v};this.map.set(k,n);this._af(n);if(this.map.size>this.cap){const l=this.t.prev;this._rm(l);this.map.delete(l.k);}}}}
function run(cap,ops){const c=new LRUCacheRef(cap);return ops.map(([op,...a])=>op==='put'?(c.put(a[0],a[1]),null):c.get(a[0]));}`,
    validatorRunner: `
let p=0,f=0;
const r1=run(2,[['put',1,1],['put',2,2],['get',1],['put',3,3],['get',2],['get',1],['get',3]]);const e1=[null,null,1,null,-1,1,3];
if(JSON.stringify(r1)===JSON.stringify(e1))p++;else{f++;console.log('‚ùå Test 1: '+JSON.stringify(r1)+' vs '+JSON.stringify(e1));}
const r2=run(2,[['put',1,1],['put',2,2],['put',3,3],['get',1]]);const e2=[null,null,null,-1];
if(JSON.stringify(r2)===JSON.stringify(e2))p++;else{f++;console.log('‚ùå Test 2: '+JSON.stringify(r2)+' vs '+JSON.stringify(e2));}
const r3=run(1,[['put',2,1],['get',2],['put',3,2],['get',2],['get',3]]);const e3=[null,1,null,-1,2];
if(JSON.stringify(r3)===JSON.stringify(e3))p++;else{f++;console.log('‚ùå Test 3: '+JSON.stringify(r3)+' vs '+JSON.stringify(e3));}
if(f===0)console.log('ALL_PASS:'+p+'/'+p+' test cases passed');
else console.log('PARTIAL:'+p+'/'+(p+f)+' test cases passed');`,
    fixChecks: {
      python: [
        { pattern: /if\s+len\s*\(\s*self\s*\.\s*cache\s*\)\s*>\s*self\s*\.\s*capacity\s*[^+]/, description: 'Fix BUG 1: evict when len(cache) > self.capacity (not +1)' },
        { pattern: /self\s*\.\s*_remove\s*\(\s*node\s*\)/, description: 'Fix BUG 2: call self._remove(node) before _add_to_front' },
        { pattern: /del\s+self\s*\.\s*cache\s*\[\s*lru\s*\.\s*key\s*\]/, description: 'Fix BUG 3: del self.cache[lru.key] after eviction' },
      ],
      cpp: [
        { pattern: /\(\s*int\s*\)\s*dll\s*\.\s*size\s*\(\s*\)\s*>\s*cap\s*[^+]/, description: 'Fix BUG 1: evict when size > cap (not cap+1)' },
        { pattern: /mp\s*\.\s*erase\s*\(/, description: 'Fix BUG 2 & 3: mp.erase(lru.first) before dll.pop_back()' },
      ],
      java: [
        { pattern: /map\s*\.\s*size\s*\(\s*\)\s*>\s*capacity\s*[^+]/, description: 'Fix BUG 1: evict when map.size() > capacity (not +1)' },
        { pattern: /remove\s*\(\s*n\s*\)/, description: 'Fix BUG 2: call remove(n) before addFront in get/put' },
        { pattern: /map\s*\.\s*remove\s*\(\s*lru\s*\.\s*key\s*\)/, description: 'Fix BUG 3: map.remove(lru.key) after eviction' },
      ],
      c: [
        { pattern: /c\s*->\s*size\s*>\s*c\s*->\s*capacity\s*[^+]/, description: 'Fix BUG 1: evict when size > capacity (not +1)' },
        { pattern: /removeNode\s*\(\s*cur\s*\)/, description: 'Fix BUG 2: removeNode before addFront for existing nodes' },
        { pattern: /free\s*\(\s*lru\s*\)/, description: 'Fix BUG 3: free(lru) to prevent memory leak' },
      ],
    },
    solvedBy: false
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // Q8 ‚Äî MEDIAN DATA STREAM ATTACK (INSANE)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    id: 8,
    title: "Median Data Stream Attack",
    difficulty: "INSANE",
    points: 500,
    category: "Heaps",
    description: "‚ö† MAXIMUM THREAT LEVEL. The real-time threat scoring system uses a dual-heap median tracker to compute live threat medians from a data stream. A state-sponsored actor planted two bugs: the heap balancing condition is inverted (maxHeap and minHeap swap sizes incorrectly) and the median formula for even-count is wrong (uses wrong heap). The threat scores are completely fabricated. Every decision is wrong. Fix both bugs or the entire grid goes dark.",
    constraints: ["‚àí10‚Åµ ‚â§ num ‚â§ 10‚Åµ", "At least one element before getMedian", "Up to 5√ó10‚Å¥ addNum calls"],
    examples: [
      { input: "addNum(1), addNum(2), getMedian()", output: "1.5" },
      { input: "addNum(3), getMedian()",             output: "2.0" },
      { input: "addNum(1), addNum(1), getMedian()",  output: "1.0" }
    ],
    hints: [
      "maxHeap stores the smaller half ‚Äî it should always be equal to or 1 larger than minHeap",
      "The rebalance condition is inverted: it rebalances when it should not and vice versa",
      "For even count, median = (maxHeap.top + minHeap.top) / 2 ‚Äî check which heap is which"
    ],
    buggyCode: {
      javascript: `class MedianFinder {
  constructor() {
    // maxHeap: stores lower half (simulated with negation)
    // minHeap: stores upper half
    this.maxHeap = new MinHeap(); // actually used as max via negation
    this.minHeap = new MinHeap();
  }
  
  addNum(num) {
    this.maxHeap.push(-num); // negate for max behavior
    
    // Balance: maxHeap should have equal or 1 more element
    // BUG 1: condition inverted ‚Äî rebalances the wrong direction
    if (this.minHeap.size() > this.maxHeap.size()) {
      this.minHeap.push(-this.maxHeap.pop());
    }
    
    // Ensure ordering: max of lower half <= min of upper half
    if (this.maxHeap.size() > 0 && this.minHeap.size() > 0 &&
        -this.maxHeap.peek() > this.minHeap.peek()) {
      this.minHeap.push(-this.maxHeap.pop());
      this.maxHeap.push(-this.minHeap.pop());
    }
  }
  
  getMedian() {
    if (this.maxHeap.size() > this.minHeap.size()) {
      return -this.maxHeap.peek();
    }
    // BUG 2: even count ‚Äî should be (-maxHeap.peek() + minHeap.peek()) / 2
    return (-this.minHeap.peek() + this.maxHeap.peek()) / 2;
  }
}

class MinHeap {
  constructor(){this.h=[];}
  size(){return this.h.length;}
  peek(){return this.h[0];}
  push(v){this.h.push(v);this._up(this.h.length-1);}
  pop(){const t=this.h[0];const l=this.h.pop();if(this.h.length){this.h[0]=l;this._down(0);}return t;}
  _up(i){while(i>0){const p=(i-1)>>1;if(this.h[p]<=this.h[i])break;[this.h[p],this.h[i]]=[this.h[i],this.h[p]];i=p;}}
  _down(i){const n=this.h.length;while(true){let s=i,l=2*i+1,r=2*i+2;if(l<n&&this.h[l]<this.h[s])s=l;if(r<n&&this.h[r]<this.h[s])s=r;if(s===i)break;[this.h[s],this.h[i]]=[this.h[i],this.h[s]];i=s;}}
}`,
      python: `import heapq

class MedianFinder:
    def __init__(self):
        # max_heap: lower half (negated for max behavior)
        # min_heap: upper half
        self.max_heap = []  # negated values
        self.min_heap = []
    
    def add_num(self, num: int) -> None:
        heapq.heappush(self.max_heap, -num)
        
        # BUG 1: condition inverted ‚Äî wrong rebalance direction
        if len(self.min_heap) > len(self.max_heap):
            heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap))
        
        # maintain ordering
        if self.max_heap and self.min_heap and (-self.max_heap[0] > self.min_heap[0]):
            heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap))
            heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap))
    
    def get_median(self) -> float:
        if len(self.max_heap) > len(self.min_heap):
            return float(-self.max_heap[0])
        # BUG 2: wrong ‚Äî should be (-max_heap[0] + min_heap[0]) / 2
        return (-self.min_heap[0] + self.max_heap[0]) / 2`,
      cpp: `class MedianFinder {
    priority_queue<int> maxH;           // lower half
    priority_queue<int,vector<int>,greater<int>> minH; // upper half
public:
    void addNum(int num) {
        maxH.push(num);
        
        // BUG 1: inverted ‚Äî should rebalance when maxH is more than 1 ahead
        if (minH.size() > maxH.size()) {
            minH.push(maxH.top()); maxH.pop();
        }
        
        if (!maxH.empty() && !minH.empty() && maxH.top() > minH.top()) {
            minH.push(maxH.top()); maxH.pop();
            maxH.push(minH.top()); minH.pop();
        }
    }
    
    double findMedian() {
        if (maxH.size() > minH.size()) return maxH.top();
        // BUG 2: wrong heaps ‚Äî should be (maxH.top() + minH.top()) / 2.0
        return (minH.top() + maxH.top()) / 2.0; // order is fine but read carefully
    }
};`,
      java: `class MedianFinder {
    PriorityQueue<Integer> maxH = new PriorityQueue<>(Collections.reverseOrder());
    PriorityQueue<Integer> minH = new PriorityQueue<>();
    
    public void addNum(int num) {
        maxH.offer(num);
        
        // BUG 1: condition inverted ‚Äî rebalances the wrong way
        if (minH.size() > maxH.size()) {
            minH.offer(maxH.poll());
        }
        
        if (!maxH.isEmpty() && !minH.isEmpty() && maxH.peek() > minH.peek()) {
            minH.offer(maxH.poll());
            maxH.offer(minH.poll());
        }
    }
    
    public double findMedian() {
        if (maxH.size() > minH.size()) return maxH.peek();
        // BUG 2: wrong ‚Äî should be (maxH.peek() + minH.peek()) / 2.0
        return (minH.peek() + maxH.peek()) / 2.0;
    }
}`,
      c: `/* C implementation using sorted insert simulation */
#define MAXN 100005
int data[MAXN];
int dataSize = 0;

void addNum(int num) {
    /* Insert in sorted position */
    int i = dataSize - 1;
    while (i >= 0 && data[i] > num) {
        data[i+1] = data[i];
        i--;
    }
    data[i+1] = num;
    dataSize++;
}

double findMedian() {
    if (dataSize % 2 == 1) {
        return (double)data[dataSize / 2];
    }
    /* BUG: integer division truncates ‚Äî should cast before dividing */
    return (data[dataSize/2 - 1] + data[dataSize/2]) / 2; /* BUG: integer division */
}`
    },
    testCode: {
      javascript: `
class MFRef {
  constructor(){this.lo=[];this.hi=[];}
  _pushMax(v){this.lo.push(v);this.lo.sort((a,b)=>b-a);}
  _pushMin(v){this.hi.push(v);this.hi.sort((a,b)=>a-b);}
  addNum(n){
    this._pushMax(n);
    if(this.hi.length&&this.lo[0]>this.hi[0]){this._pushMin(this.lo.shift());this.lo.sort((a,b)=>b-a);}
    if(this.lo.length>this.hi.length+1){this._pushMin(this.lo.shift());}
    else if(this.hi.length>this.lo.length){this._pushMax(this.hi.shift());}
  }
  getMedian(){if(this.lo.length>this.hi.length)return this.lo[0];return(this.lo[0]+this.hi[0])/2;}
}
let p=0,f=0;
function close(a,b){return Math.abs(a-b)<0.001;}
const m1=new MFRef();
m1.addNum(1);m1.addNum(2);
if(close(m1.getMedian(),1.5))p++;else{f++;console.log('‚ùå Test 1: got '+m1.getMedian()+' expected 1.5');}
m1.addNum(3);
if(close(m1.getMedian(),2.0))p++;else{f++;console.log('‚ùå Test 2: got '+m1.getMedian()+' expected 2.0');}
const m2=new MFRef();
m2.addNum(1);m2.addNum(1);
if(close(m2.getMedian(),1.0))p++;else{f++;console.log('‚ùå Test 3: got '+m2.getMedian()+' expected 1.0');}
const m3=new MFRef();
[6,1,4,2,7,3,5].forEach(x=>m3.addNum(x));
if(close(m3.getMedian(),4.0))p++;else{f++;console.log('‚ùå Test 4: got '+m3.getMedian()+' expected 4.0');}
const m4=new MFRef();
[5,3].forEach(x=>m4.addNum(x));
if(close(m4.getMedian(),4.0))p++;else{f++;console.log('‚ùå Test 5: got '+m4.getMedian()+' expected 4.0');}
if(f===0)console.log('ALL_PASS:'+p+'/'+p+' test cases passed');
else console.log('PARTIAL:'+p+'/'+(p+f)+' test cases passed');`
    },
    testCases: [
      { label:'Test 1', input:['addNum(1,2) ‚Üí getMedian'],   expected:'1.5',  wrongOutput:'wrong' },
      { label:'Test 2', input:['addNum(3) ‚Üí getMedian'],      expected:'2.0',  wrongOutput:'wrong' },
      { label:'Test 3', input:['addNum(1,1) ‚Üí getMedian'],    expected:'1.0',  wrongOutput:'wrong' },
      { label:'Test 4', input:['stream [6,1,4,2,7,3,5]'],     expected:'4.0',  wrongOutput:'wrong' },
      { label:'Test 5', input:['addNum(5,3) ‚Üí getMedian'],    expected:'4.0',  wrongOutput:'wrong' },
    ],
    validator: `
class MFRef{constructor(){this.lo=[];this.hi=[];}
_pm(v){this.lo.push(v);this.lo.sort((a,b)=>b-a);}
_pn(v){this.hi.push(v);this.hi.sort((a,b)=>a-b);}
addNum(n){this._pm(n);if(this.hi.length&&this.lo[0]>this.hi[0]){this._pn(this.lo.shift());}if(this.lo.length>this.hi.length+1){this._pn(this.lo.shift());}else if(this.hi.length>this.lo.length){this._pm(this.hi.shift());}}
getMedian(){if(this.lo.length>this.hi.length)return this.lo[0];return(this.lo[0]+this.hi[0])/2;}}`,
    validatorRunner: `
function close(a,b){return Math.abs(a-b)<0.001;}
let p=0,f=0;
const m1=new MFRef();m1.addNum(1);m1.addNum(2);
if(close(m1.getMedian(),1.5))p++;else{f++;console.log('‚ùå Test 1: got '+m1.getMedian()+' exp 1.5');}
m1.addNum(3);
if(close(m1.getMedian(),2.0))p++;else{f++;console.log('‚ùå Test 2: got '+m1.getMedian()+' exp 2.0');}
const m2=new MFRef();m2.addNum(1);m2.addNum(1);
if(close(m2.getMedian(),1.0))p++;else{f++;console.log('‚ùå Test 3: got '+m2.getMedian()+' exp 1.0');}
const m3=new MFRef();[6,1,4,2,7,3,5].forEach(x=>m3.addNum(x));
if(close(m3.getMedian(),4.0))p++;else{f++;console.log('‚ùå Test 4: got '+m3.getMedian()+' exp 4.0');}
const m4=new MFRef();[5,3].forEach(x=>m4.addNum(x));
if(close(m4.getMedian(),4.0))p++;else{f++;console.log('‚ùå Test 5: got '+m4.getMedian()+' exp 4.0');}
if(f===0)console.log('ALL_PASS:'+p+'/'+p+' test cases passed');
else console.log('PARTIAL:'+p+'/'+(p+f)+' test cases passed');`,
    fixChecks: {
      python: [
        { pattern: /len\s*\(\s*self\s*\.\s*max_heap\s*\)\s*>\s*len\s*\(\s*self\s*\.\s*min_heap\s*\)\s*\+\s*1/, description: 'Fix BUG 1: rebalance when len(max_heap) > len(min_heap) + 1' },
        { pattern: /return\s*\(\s*-\s*self\s*\.\s*max_heap\s*\[\s*0\s*\]\s*\+\s*self\s*\.\s*min_heap\s*\[\s*0\s*\]\s*\)\s*\/\s*2/, description: 'Fix BUG 2: return (-max_heap[0] + min_heap[0]) / 2' },
      ],
      cpp: [
        { pattern: /maxH\s*\.\s*size\s*\(\s*\)\s*>\s*minH\s*\.\s*size\s*\(\s*\)\s*\+\s*1/, description: 'Fix BUG 1: rebalance when maxH.size() > minH.size() + 1' },
        { pattern: /\(\s*maxH\s*\.\s*top\s*\(\s*\)\s*\+\s*minH\s*\.\s*top\s*\(\s*\)\s*\)\s*\/\s*2\.0/, description: 'Fix BUG 2: (maxH.top() + minH.top()) / 2.0' },
      ],
      java: [
        { pattern: /maxH\s*\.\s*size\s*\(\s*\)\s*>\s*minH\s*\.\s*size\s*\(\s*\)\s*\+\s*1/, description: 'Fix BUG 1: rebalance when maxH.size() > minH.size() + 1' },
        { pattern: /\(\s*maxH\s*\.\s*peek\s*\(\s*\)\s*\+\s*minH\s*\.\s*peek\s*\(\s*\)\s*\)\s*\/\s*2\.0/, description: 'Fix BUG 2: (maxH.peek() + minH.peek()) / 2.0' },
      ],
      c: [
        { pattern: /\(\s*double\s*\)\s*\(\s*data\s*\[/, description: 'Fix BUG 1 & 2: cast to double before division for correct median' },
      ],
    },
    solvedBy: false
  }
];

const TOTAL_TIME = 45 * 60; // 45 minutes for 8 questions
const STORAGE_KEY = 'debug_terminal_v3';

// ===== EXECUTION ENGINE ‚Äî SOLUTION COMPARISON (100% offline) =====
//
// How it works (LeetCode-style feel, zero network):
//   RUN   ‚Üí runs user's JS code in a sandboxed Web Worker with custom input
//           Python/C++: parses the code for known bug fixes, then simulates
//   SUBMIT ‚Üí evaluates user code against predefined test cases via JS reference
//           implementations. Python/C++: smart structural validation + test matching.
//
// Each QUESTION has:
//   testCases   ‚Äî array of { input, expected, label }
//   validator   ‚Äî JS function (userCode, lang) ‚Üí { passed, results[] }
//   fixChecks   ‚Äî per-language regex hints to detect whether bugs are fixed

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// JS SANDBOX ‚Äî runs arbitrary JS in a Web Worker
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function runInSandbox(code, timeoutMs = 4000) {
  return new Promise((resolve) => {
    const workerSrc = `
      self.onmessage = function(e) {
        const logs = [];
        const con = {
          log:   (...a) => logs.push(a.map(x => typeof x==='object'?JSON.stringify(x):String(x)).join(' ')),
          error: (...a) => logs.push('ERR: '+a.join(' ')),
          warn:  (...a) => logs.push('WARN: '+a.join(' ')),
        };
        try {
          new Function('console', e.data)(con);
          self.postMessage({ ok: true, logs });
        } catch(err) {
          self.postMessage({ ok: false, error: String(err.message||err), logs });
        }
      };
    `;
    const blob = new Blob([workerSrc], { type: 'application/javascript' });
    const url  = URL.createObjectURL(blob);
    const w    = new Worker(url);
    const tid  = setTimeout(() => {
      w.terminate(); URL.revokeObjectURL(url);
      resolve({ ok: false, logs: ['‚ö† Execution timed out ‚Äî possible infinite loop.'] });
    }, timeoutMs);
    w.onmessage = ({ data }) => {
      clearTimeout(tid); w.terminate(); URL.revokeObjectURL(url);
      resolve(data);
    };
    w.onerror = (e) => {
      clearTimeout(tid); w.terminate(); URL.revokeObjectURL(url);
      resolve({ ok: false, logs: [`Error: ${e.message||'Worker error'}`] });
    };
    w.postMessage(code);
  });
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// LANGUAGE-AWARE CODE NORMALISER
// Strips comments and normalises whitespace so we can pattern-match fixes
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function stripComments(code) {
  // remove // ‚Ä¶  and /* ‚Ä¶ */ style comments
  return code.replace(/\/\/[^\n]*/g, '').replace(/\/\*[\s\S]*?\*\//g, '').replace(/\s+/g, ' ').trim();
}
function pyStrip(code) {
  return code.replace(/#[^\n]*/g, '').replace(/\s+/g, ' ').trim();
}
function normalise(code, lang) {
  return lang === 'python' ? pyStrip(code) : stripComments(code);
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// FIX-DETECTION HELPERS (used for Python & C++)
// Returns { allFixed, fixedCount, totalFixes, details[] }
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function detectFixes(code, lang, checks) {
  const n = normalise(code, lang);
  let fixed = 0;
  const details = checks.map(({ pattern, description }) => {
    const ok = typeof pattern === 'function' ? pattern(n) : pattern.test(n);
    if (ok) fixed++;
    return { ok, description };
  });
  return { allFixed: fixed === checks.length, fixedCount: fixed, totalFixes: checks.length, details };
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// SIMULATE TEST RESULTS for Python / C++
// Runs the CORRECT JS reference solution against test cases,
// then pretends the Python/C++ code produced the same output
// (only if fix-detection says all bugs are patched).
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function simulatePythonCpp(question, userCode, lang, mode) {
  const checks = question.fixChecks && question.fixChecks[lang];
  if (!checks) return { success: false, output: `‚ö† Validation not available for ${lang}`, passed: false };

  const { allFixed, fixedCount, totalFixes, details } = detectFixes(userCode, lang, checks);

  if (mode === 'run') {
    // For RUN mode: show a nice simulated output
    const lines = [];
    lines.push(`> ${lang === 'python' ? 'Python 3' : 'C++'} ‚Äî Static analysis`);
    lines.push('‚îÄ'.repeat(40));
    details.forEach(d => lines.push(`${d.ok ? '‚úÖ' : '‚ùå'} ${d.description}`));
    lines.push('‚îÄ'.repeat(40));
    if (allFixed) {
      lines.push('‚úÖ All bugs detected as fixed. Submit to verify.');
    } else {
      lines.push(`‚ö† ${fixedCount}/${totalFixes} fixes detected. Keep going.`);
    }
    return { success: true, output: lines.join('\n'), passed: false };
  }

  // SUBMIT mode
  if (!allFixed) {
    // Run correct solution to get expected, then show failures based on unfixed bugs
    const tc = question.testCases;
    const failLines = [];
    // Figure out which test cases would still fail based on bug count
    const failStart = Math.floor((fixedCount / totalFixes) * tc.length);
    tc.forEach((t, i) => {
      if (i >= failStart) {
        failLines.push(`‚ùå ${t.label}: got ${t.wrongOutput || 'wrong answer'}, expected ${t.expected}`);
      }
    });
    const partial = `PARTIAL:${failStart}/${tc.length} test cases passed`;
    return {
      success: true,
      output: failLines.join('\n') + '\n' + partial,
      passed: false
    };
  }

  // All fixed ‚Äî run against test cases using JS reference solution
  return await runJSValidator(question);
}

// Run the JS reference validator and return results
async function runJSValidator(question) {
  const validatorCode = question.validator + '\n' + question.validatorRunner;
  const result = await runInSandbox(validatorCode);
  const output = (result.logs || []).join('\n');
  const passed = output.includes('ALL_PASS');
  return { success: result.ok, output, passed };
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// PUBLIC API
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function executeRunCode(language, userCode, customInput) {
  if (language === 'javascript') {
    const code = customInput && customInput.trim()
      ? userCode + '\n' + customInput
      : userCode;
    const result = await runInSandbox(code);
    const output = (result.logs || []).join('\n') || (result.ok ? '(no output)' : result.error || 'Error');
    return { success: result.ok, output, passed: false };
  }
  // Python / C++ ‚Äî static analysis mode for RUN
  const question = window.__currentQuestion;
  if (!question) return { success: false, output: '‚ö† No question context', passed: false };
  return simulatePythonCpp(question, userCode, language, 'run');
}

async function executeSubmitCode(language, userCode, testCode) {
  if (language === 'javascript') {
    // Extract JS validator from testCode object
    const jsTest = (testCode && typeof testCode === 'object') ? testCode.javascript : (testCode || '');
    const code = userCode + '\n' + jsTest;
    const result = await runInSandbox(code);
    const output = (result.logs || []).join('\n') || (result.ok ? '(no output)' : result.error || 'Error');
    const passed = output.includes('ALL_PASS');
    return { success: result.ok, output, passed };
  }
  // Python / C++ ‚Äî fix detection + simulated test run
  const question = window.__currentQuestion;
  if (!question) return { success: false, output: '‚ö† No question context', passed: false };
  return simulatePythonCpp(question, userCode, language, 'submit');
}

// ===== LOADING SCREEN =====
function LoadingScreen({ onComplete }) {
  const [progress, setProgress] = useState(0);
  const [logs, setLogs] = useState([]);
  const bootLogs = [
    '> Initializing cyber arena...',
    '> Loading question database...',
    '> Connecting to execution sandbox...',
    '> Multi-language runtime ready (JS/Python/C++/Java/C)...',
    '> Injecting bugs into codebase...',
    '> Arming timer module...',
    '> System ready. Good luck, hacker.',
  ];
  useEffect(() => {
    let i = 0;
    const interval = setInterval(() => {
      setProgress(p => Math.min(p + 100 / bootLogs.length, 100));
      setLogs(l => [...l, bootLogs[i]]);
      i++;
      if (i >= bootLogs.length) {
        clearInterval(interval);
        setTimeout(onComplete, 700);
      }
    }, 350);
    return () => clearInterval(interval);
  }, []);

  return (
    <div className="loading-screen">
      <div className="hex-bg">
        {Array.from({length:20}).map((_,i) => (
          <span key={i} className="hex" style={{
            left: `${Math.random()*100}%`,
            top: `${Math.random()*100}%`,
            animationDelay: `${Math.random()*4}s`,
            animationDuration: `${4+Math.random()*4}s`,
            fontSize: `${0.8+Math.random()*1.2}rem`
          }}>{['0x','>>','{}','[]','<>','&&','||','!=','==','//'][Math.floor(Math.random()*10)]}</span>
        ))}
      </div>
      <div style={{position:'relative',zIndex:1,textAlign:'center'}}>
        <div className="loading-logo">DEBUG TERMINAL</div>
        <div className="loading-subtitle">CYBER ARENA v2.0</div>
        <div style={{marginTop:'14px',fontFamily:"'Share Tech Mono'",fontSize:'0.7rem',color:'var(--text-dim)',letterSpacing:'4px'}}>
          HACKER CHALLENGE SYSTEM
        </div>
        <div className="loading-bar-container">
          <div className="loading-bar-fill" style={{width:`${progress}%`, transition:'width 0.3s ease'}}></div>
        </div>
        <div className="loading-log" style={{marginTop:'20px',height:'140px'}}>
          {logs.map((log, i) => (
            <div key={i} className="loading-log-line" style={{animationDelay:`${i*0.05}s`, color: i===logs.length-1?'var(--neon)':'var(--text-dim)'}}>
              {log}{i===logs.length-1&&<span className="terminal-cursor"></span>}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

// ===== HEADER =====
function Header({ timeLeft, currentQ, questions, score, onQSelect, solvedSet }) {
  const minutes = Math.floor(timeLeft / 60).toString().padStart(2, '0');
  const seconds = (timeLeft % 60).toString().padStart(2, '0');
  const isUrgent = timeLeft < 300;
  const isVeryUrgent = timeLeft < 60;

  return (
    <div className="header">
      <div style={{display:'flex',alignItems:'center',gap:'20px'}}>
        <div className="header-logo">‚ö° DEBUG TERMINAL</div>
        <div className="q-nav">
          {questions.map((q,i) => (
            <div key={q.id} className={`q-num ${i===currentQ?'active':''} ${solvedSet.has(i)?'solved':''}`} onClick={()=>onQSelect(i)} title={q.title}>
              {solvedSet.has(i)?'‚úì':i+1}
            </div>
          ))}
        </div>
      </div>
      <div style={{display:'flex',alignItems:'center',gap:'20px'}}>
        <div style={{fontFamily:"'Share Tech Mono'",fontSize:'0.75rem',color:'var(--text-dim)'}}>
          SCORE: <span style={{color:'var(--neon)',fontFamily:"'Orbitron'"}}>{score}</span>
        </div>
        <div className={`timer-display neon-glow ${isUrgent?'urgent':''}`} style={{color:isUrgent?'var(--red)':'var(--neon)'}}>
          {isVeryUrgent && '‚ö† '}{minutes}:{seconds}
        </div>
      </div>
    </div>
  );
}

// ===== LEFT PANEL =====
function LeftPanel({ question, language }) {
  return (
    <div className="left-panel">
      <div className="panel-card" style={{borderColor:'rgba(0,255,136,0.3)',animation:'fadeInUp 0.3s ease'}}>
        <div style={{display:'flex',alignItems:'center',gap:'10px',marginBottom:'8px',flexWrap:'wrap'}}>
          <span className={`badge badge-${question.difficulty.toLowerCase()}`}>{question.difficulty}</span>
          <span style={{fontFamily:"'Share Tech Mono'",fontSize:'0.65rem',color:'var(--text-dim)',letterSpacing:'2px'}}>{question.category}</span>
          <span style={{marginLeft:'auto',fontFamily:"'Orbitron'",fontSize:'0.7rem',color:'var(--neon)'}}>+{question.points}pts</span>
        </div>
        <div className="panel-title">{question.title}</div>
      </div>

      <div className="panel-card">
        <h3>MISSION BRIEFING</h3>
        <p className="problem-desc">{question.description}</p>
      </div>

      <div className="panel-card">
        <h3>BUGGY CODE</h3>
        <div className="buggy-code">{question.buggyCode[language] || question.buggyCode.javascript}</div>
      </div>

      <div className="panel-card">
        <h3>EXAMPLES</h3>
        {question.examples.map((ex, i) => (
          <div key={i} className="example-box" style={{marginBottom:'8px'}}>
            <div className="example-label">CASE {i+1}</div>
            <div><span style={{color:'var(--text-dim)',fontSize:'0.72rem'}}>Input: </span><span className="example-val">{ex.input}</span></div>
            <div><span style={{color:'var(--text-dim)',fontSize:'0.72rem'}}>Output: </span><span className="example-val">{ex.output}</span></div>
          </div>
        ))}
      </div>

      <div className="panel-card">
        <h3>CONSTRAINTS</h3>
        <div style={{display:'flex',flexWrap:'wrap',gap:'4px'}}>
          {question.constraints.map((c,i) => <span key={i} className="constraint">{c}</span>)}
        </div>
      </div>

      <div className="panel-card">
        <h3>HINTS (USE WITH CAUTION)</h3>
        {question.hints.map((h,i) => <div key={i} className="hint-item">{h}</div>)}
      </div>
    </div>
  );
}

// ===== RIGHT PANEL =====
function RightPanel({ question, disabled, onRunResult, outputLines, activeTab, setActiveTab, customInput, setCustomInput, language, setLanguage }) {
  const editorContainerRef = useRef(null);
  const editorRef = useRef(null);
  const monacoRef = useRef(null);
  // language/setLanguage come from App props
  const [isRunning, setIsRunning] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);

  const prevQIdRef = useRef(question.id);
  const prevLangRef = useRef(language);


  const getCode = useCallback(() => {
    return question.buggyCode[language];
  }, [question, language]);

  useEffect(() => {
    window.__currentQuestion = question;
  }, []);

  useEffect(() => {
    require(['vs/editor/editor.main'], function(monaco) {
      if (!editorContainerRef.current) return;
      monacoRef.current = monaco;

      monaco.editor.defineTheme('hacker', {
        base: 'vs-dark',
        inherit: true,
        rules: [
          { token: '', foreground: 'c8ffd4', background: '050a07' },
          { token: 'keyword', foreground: '00ff88', fontStyle: 'bold' },
          { token: 'comment', foreground: '3a6b4a', fontStyle: 'italic' },
          { token: 'string', foreground: '88ffcc' },
          { token: 'number', foreground: 'ff9966' },
          { token: 'delimiter', foreground: '00cc66' },
          { token: 'identifier', foreground: 'aaffcc' },
        ],
        colors: {
          'editor.background': '#050a07',
          'editor.foreground': '#c8ffd4',
          'editorLineNumber.foreground': '#1a4a2a',
          'editorLineNumber.activeForeground': '#00ff88',
          'editor.lineHighlightBackground': '#0a1a0d',
          'editorCursor.foreground': '#00ff88',
          'editor.selectionBackground': '#00ff8830',
          'editorIndentGuide.background': '#0d2016',
          'editorIndentGuide.activeBackground': '#00ff8840',
          'scrollbarSlider.background': '#00ff8830',
          'scrollbarSlider.hoverBackground': '#00ff8850',
          'editorGutter.background': '#050a07',
        }
      });

      if (editorRef.current) {
        editorRef.current.dispose();
      }

      editorRef.current = monaco.editor.create(editorContainerRef.current, {
        value: question.buggyCode[language],
        language: language,
        theme: 'hacker',
        fontSize: 13,
        fontFamily: "'JetBrains Mono', 'Courier New', monospace",
        fontLigatures: true,
        minimap: { enabled: false },
        scrollBeyondLastLine: false,
        automaticLayout: true,
        lineNumbers: 'on',
        renderWhitespace: 'none',
        cursorBlinking: 'phase',
        cursorStyle: 'line',
        wordWrap: 'on',
        padding: { top: 14, bottom: 14 },
        glyphMargin: false,
        folding: true,
        lineDecorationsWidth: 8,
        contextmenu: false,
        readOnly: disabled,
      });

      prevQIdRef.current = question.id;
      prevLangRef.current = language;
    });
  }, []);

  // Update editor on question/language change
  useEffect(() => {
    window.__currentQuestion = question;
    if (!editorRef.current || !monacoRef.current) return;
    const newCode = question.buggyCode[language];
    if (prevQIdRef.current !== question.id || prevLangRef.current !== language) {
      editorRef.current.setValue(newCode);
      monacoRef.current.editor.setModelLanguage(editorRef.current.getModel(),
        language === 'cpp' ? 'cpp' : language === 'java' ? 'java' : language === 'c' ? 'c' : language);
      prevQIdRef.current = question.id;
      prevLangRef.current = language;
    }
  }, [question.id, language]);

  // Update read-only state
  useEffect(() => {
    if (editorRef.current) {
      editorRef.current.updateOptions({ readOnly: disabled });
    }
  }, [disabled]);

  const getCurrentCode = () => {
    if (editorRef.current) return editorRef.current.getValue();
    return question.buggyCode[language];
  };

  const handleRun = () => {
    if (disabled) return;
    setIsRunning(true);
    setActiveTab('output');
    onRunResult({ type: 'run', success: true, output: `‚ü≥ Executing in sandbox...` });
    const code = getCurrentCode();
    const input = customInput.trim() ? customInput : '';
    executeRunCode(language, code, input)
      .then(result => {
        onRunResult({ type: 'run', ...result });
      })
      .catch(err => {
        onRunResult({ type: 'run', success: false, output: `üí• ${err.message}` });
      })
      .finally(() => {
        setIsRunning(false);
      });
  };

  const handleSubmit = () => {
    if (disabled) return;
    setIsSubmitting(true);
    setActiveTab('output');
    onRunResult({ type: 'submit', success: true, output: `‚ü≥ Running test cases...` });
    const code = getCurrentCode();
    executeSubmitCode(language, code, question.testCode)
      .then(result => {
        onRunResult({ type: 'submit', ...result });
      })
      .catch(err => {
        onRunResult({ type: 'submit', success: false, output: `üí• ${err.message}`, passed: false });
      })
      .finally(() => {
        setIsSubmitting(false);
      });
  };

  return (
    <div className="right-panel" style={{position:'relative'}}>
      {disabled && (
        <div className="disabled-overlay">
          <div style={{textAlign:'center'}}>
            <div style={{fontFamily:"'Orbitron'",fontSize:'2rem',fontWeight:900,color:'var(--red)',textShadow:'0 0 20px var(--red)'}}>
              TIME'S UP
            </div>
            <div style={{fontFamily:"'Share Tech Mono'",color:'var(--text-dim)',marginTop:'8px',fontSize:'0.8rem'}}>
              Session terminated
            </div>
          </div>
        </div>
      )}
      <div className="editor-toolbar">
        <div className="lang-selector">
          {[
            {id:'javascript', label:'JS'},
            {id:'python',     label:'Python'},
            {id:'cpp',        label:'C++'},
            {id:'java',       label:'Java'},
            {id:'c',          label:'C'},
          ].map(({id:lng, label}) => (
            <button key={lng} className={`lang-btn ${language===lng?'active':''}`}
              onClick={()=>setLanguage(lng)}>
              {label}
            </button>
          ))}
        </div>
        <div style={{fontFamily:"'Share Tech Mono'",fontSize:'0.62rem',letterSpacing:'1px',display:'flex',alignItems:'center',gap:'6px',color:language==='javascript'?'rgba(0,255,136,0.55)':language==='java'?'rgba(255,180,50,0.7)':language==='c'?'rgba(200,200,255,0.7)':'rgba(100,200,255,0.65)'}}>
          <span style={{display:'inline-block',width:'6px',height:'6px',borderRadius:'50%',background:language==='javascript'?'var(--neon)':language==='java'?'#ffb432':'#64c8ff',boxShadow:language==='javascript'?'0 0 6px var(--neon)':language==='java'?'0 0 6px #ffb432':'0 0 6px #64c8ff',animation:'pulseBorder 1.5s infinite'}}></span>
          {language === 'javascript' ? '‚ö° JS ‚Äî Local Sandbox' :
           language === 'python' ? 'üêç Python ‚Äî Fix Validator' :
           language === 'java'   ? '‚òï Java ‚Äî Fix Validator' :
           language === 'c'      ? '‚öô C ‚Äî Fix Validator' :
                                   '‚öô C++ ‚Äî Fix Validator'}
        </div>
      </div>

      <div className="editor-container">
        <div id="monaco-container" ref={editorContainerRef}></div>
      </div>

      <div className="bottom-panel">
        <div className="bottom-tabs">
          <button className={`btab ${activeTab==='output'?'active':''}`} onClick={()=>setActiveTab('output')}>OUTPUT</button>
          <button className={`btab ${activeTab==='input'?'active':''}`} onClick={()=>setActiveTab('input')}>CUSTOM INPUT</button>
        </div>
        <div className="output-area">
          {activeTab === 'output' && (
            outputLines.length === 0 ? (
              <span className="output-prompt">$ Awaiting execution... <span className="terminal-cursor"></span></span>
            ) : (
              outputLines.map((line, i) => (
                <div key={i} className={
                  line.startsWith('‚úÖ')||line.includes('ALL_PASS')?'output-success':
                  line.startsWith('‚ùå')||line.startsWith('üí•')||line.toLowerCase().includes('error')?'output-error':
                  line.startsWith('‚ö†')||line.startsWith('WARN')||line.includes('PARTIAL')?'output-warn':
                  'output-prompt'
                }>{line}</div>
              ))
            )
          )}
          {activeTab === 'input' && (
            <div>
              <div style={{fontFamily:"'Share Tech Mono'",fontSize:'0.68rem',color:'var(--text-dim)',letterSpacing:'2px',marginBottom:'8px'}}>
                {language === 'javascript' ? '// Custom JS to run after your code' : '// Python/C++: use RUN to check fix detection'}
              </div>
              <textarea
                className="custom-input"
                placeholder={language === 'python' ? `# Example:\nprint(binary_search([1,2,3,4,5], 3))` : language === 'cpp' ? `// Example (inside main):\ncout << binarySearch({1,2,3,4,5}, 3) << endl;` : `// Example:\nconsole.log(binarySearch([1,2,3,4,5], 3));`}
                value={customInput}
                onChange={e=>setCustomInput(e.target.value)}
              />
            </div>
          )}
        </div>
      </div>

      <div className="action-bar">
        <button className="btn btn-run" onClick={handleRun} disabled={disabled||isRunning}>
          {isRunning ? '‚ñ∂ RUNNING...' : '‚ñ∂ RUN CODE'}
        </button>
        <button className="btn btn-submit" onClick={handleSubmit} disabled={disabled||isSubmitting}>
          {isSubmitting ? '‚ü≥ TESTING...' : '‚ö° SUBMIT'}
        </button>
        <div className="score-display" style={{fontSize:'0.7rem'}}>
          {question.points}pts available
        </div>
      </div>
    </div>
  );
}

// ===== SUCCESS MODAL =====
function SuccessModal({ question, onNext, onClose, isLast }) {
  useEffect(() => {
    try {
      const ctx = new AudioContext();
      [523, 659, 784, 1047].forEach((freq, i) => {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.frequency.value = freq;
        osc.type = 'sine';
        gain.gain.setValueAtTime(0, ctx.currentTime + i*0.1);
        gain.gain.linearRampToValueAtTime(0.15, ctx.currentTime + i*0.1 + 0.05);
        gain.gain.linearRampToValueAtTime(0, ctx.currentTime + i*0.1 + 0.2);
        osc.start(ctx.currentTime + i*0.1);
        osc.stop(ctx.currentTime + i*0.1 + 0.3);
      });
    } catch(e) {}
  }, []);

  return (
    <div className="overlay">
      <div className="modal modal-success">
        <div style={{textAlign:'center'}}>
          <div style={{fontSize:'3.5rem',marginBottom:'12px',animation:'successPop 0.5s ease'}}>‚úÖ</div>
          <div style={{fontFamily:"'Orbitron'",fontSize:'1.4rem',fontWeight:900,color:'var(--neon)',marginBottom:'6px',animation:'glitchText 4s infinite'}}>
            ACCESS GRANTED
          </div>
          <div style={{fontFamily:"'Share Tech Mono'",color:'var(--text-dim)',fontSize:'0.78rem',marginBottom:'20px'}}>
            Bug successfully neutralized
          </div>
          <div style={{display:'flex',justifyContent:'center',gap:'20px',marginBottom:'24px'}}>
            <div style={{textAlign:'center',padding:'14px 24px',background:'rgba(0,255,136,0.05)',border:'1px solid var(--border)',borderRadius:'4px'}}>
              <div style={{fontFamily:"'Orbitron'",fontSize:'2rem',color:'var(--neon)',fontWeight:900}}>+{question.points}</div>
              <div style={{fontFamily:"'Share Tech Mono'",fontSize:'0.65rem',color:'var(--text-dim)',letterSpacing:'2px'}}>POINTS</div>
            </div>
          </div>
          <div style={{fontFamily:"'Share Tech Mono'",fontSize:'0.8rem',color:'var(--neon)',marginBottom:'24px',padding:'10px',background:'rgba(0,255,136,0.05)',borderRadius:'4px',border:'1px solid rgba(0,255,136,0.2)'}}>
            All test cases passed ‚úì
          </div>
          <div style={{display:'flex',gap:'10px',justifyContent:'center'}}>
            {!isLast && (
              <button className="btn btn-submit" onClick={onNext} style={{padding:'10px 30px'}}>
                NEXT MISSION ‚Üí
              </button>
            )}
            <button className="btn btn-run" onClick={onClose} style={{padding:'10px 24px'}}>
              {isLast ? '‚ö° FINAL SCORE' : 'STAY HERE'}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}

// ===== FAIL MODAL =====
function FailModal({ message, onClose }) {
  return (
    <div className="overlay" onClick={onClose}>
      <div className="modal modal-fail" style={{animation:'shake 0.4s ease',textAlign:'center'}}>
        <div style={{fontSize:'2.5rem',marginBottom:'12px'}}>üíÄ</div>
        <div style={{fontFamily:"'Orbitron'",fontSize:'1.2rem',fontWeight:900,color:'var(--red)',marginBottom:'8px',textShadow:'0 0 20px var(--red)'}}>
          ACCESS DENIED
        </div>
        <div style={{fontFamily:"'Share Tech Mono'",color:'var(--text-dim)',fontSize:'0.78rem',marginBottom:'16px'}}>
          {message}
        </div>
        <div style={{fontFamily:"'Share Tech Mono'",fontSize:'0.72rem',color:'rgba(255,100,100,0.5)',marginBottom:'20px'}}>
          Review the hints and try again, hacker.
        </div>
        <button className="btn btn-run" onClick={onClose} style={{borderColor:'var(--red)',color:'var(--red)'}}>
          RETRY
        </button>
      </div>
    </div>
  );
}

// ===== TAB WARNING =====
function TabWarning({ count, onDismiss }) {
  return (
    <div className="tab-warning" onClick={onDismiss}>
      <div className="warning-box">
        <div style={{fontSize:'2rem',marginBottom:'12px',animation:'warningFlash 0.5s infinite'}}>‚ö†Ô∏è</div>
        <div style={{fontFamily:"'Orbitron'",fontSize:'1.1rem',fontWeight:700,color:'var(--red)',marginBottom:'8px'}}>
          TAB SWITCH DETECTED
        </div>
        <div style={{fontFamily:"'Share Tech Mono'",fontSize:'0.78rem',color:'var(--text-dim)',lineHeight:1.6,marginBottom:'16px'}}>
          Suspicious activity logged.<br/>
          Tab switches: <span style={{color:'var(--red)'}}>{count}</span><br/>
          You are being monitored.
        </div>
        <button className="btn btn-run" onClick={onDismiss} style={{borderColor:'var(--red)',color:'var(--red)',fontSize:'0.65rem'}}>
          RETURN TO ARENA
        </button>
      </div>
    </div>
  );
}

// ===== FINAL SCORE =====
function FinalScreen({ questions, score, solvedSet, timeUsed, onRestart }) {
  const maxScore = questions.reduce((s,q)=>s+q.points,0);
  const mins = Math.floor(timeUsed/60);
  const secs = timeUsed%60;
  const pct = Math.round((score/maxScore)*100);
  const rank = pct>=90?'ELITE HACKER':pct>=70?'SKILLED OPERATIVE':pct>=50?'JUNIOR ANALYST':'SCRIPT KIDDIE';
  const rankColor = pct>=90?'var(--neon)':pct>=70?'#00aaff':pct>=50?'#ffaa00':'var(--red)';

  return (
    <div className="final-screen">
      <div className="final-card" style={{position:'relative',zIndex:2}}>
        <div className="final-title" style={{animation:'glitchText 3s infinite'}}>
          MISSION {solvedSet.size >= questions.length ? 'COMPLETE' : 'REPORT'}
        </div>
        <div style={{fontFamily:"'Share Tech Mono'",fontSize:'0.7rem',color:'var(--text-dim)',letterSpacing:'4px',marginBottom:'8px'}}>
          {solvedSet.size >= questions.length ? '// YOU SURVIVED THE DEBUG ARENA //' : '// SESSION TERMINATED //'}
        </div>

        <div className="score-circle">
          <div className="score-num" style={{color:rankColor}}>{score}</div>
          <div className="score-label">TOTAL SCORE</div>
        </div>

        <div style={{background:'rgba(0,255,136,0.05)',border:'1px solid var(--border)',borderRadius:'6px',padding:'8px 16px',marginBottom:'20px'}}>
          <div style={{fontFamily:"'Orbitron'",fontSize:'1rem',fontWeight:700,color:rankColor,letterSpacing:'2px'}}>
            RANK: {rank}
          </div>
        </div>

        <div style={{marginBottom:'24px'}}>
          {[
            ['SCORE', `${score} / ${maxScore} pts`],
            ['COMPLETION', `${solvedSet.size} / ${questions.length} challenges`],
            ['TIME USED', `${mins}m ${secs.toString().padStart(2,'0')}s`],
            ['ACCURACY', `${pct}%`],
          ].map(([k,v])=>(
            <div key={k} className="stat-row">
              <span className="stat-key">{k}</span>
              <span className="stat-val">{v}</span>
            </div>
          ))}
        </div>

        <div style={{marginBottom:'24px'}}>
          <div style={{fontFamily:"'Share Tech Mono'",fontSize:'0.68rem',color:'var(--text-dim)',letterSpacing:'2px',marginBottom:'10px'}}>
            CHALLENGE RESULTS
          </div>
          {questions.map((q,i)=>(
            <div key={q.id} style={{display:'flex',justifyContent:'space-between',padding:'6px 10px',marginBottom:'4px',background:'rgba(0,0,0,0.3)',borderRadius:'4px',border:`1px solid ${solvedSet.has(i)?'rgba(0,255,136,0.2)':'rgba(255,255,255,0.05)'}`}}>
              <span style={{fontFamily:"'Share Tech Mono'",fontSize:'0.76rem',color:solvedSet.has(i)?'var(--text)':'var(--text-dim)'}}>{q.title}</span>
              <span style={{fontFamily:"'Orbitron'",fontSize:'0.7rem',color:solvedSet.has(i)?'var(--neon)':'var(--text-dim)'}}>{solvedSet.has(i)?`+${q.points}`:'--'}</span>
            </div>
          ))}
        </div>

        <button className="btn btn-submit" onClick={onRestart} style={{padding:'12px 40px',fontSize:'0.75rem',letterSpacing:'3px',width:'100%'}}>
          ‚Üª RESTART ARENA
        </button>
      </div>
    </div>
  );
}

// ===== MAIN APP =====
function App() {
  const [phase, setPhase] = useState('loading'); // loading | game | final
  const [currentQ, setCurrentQ] = useState(0);
  const [score, setScore] = useState(0);
  const [solvedSet, setSolvedSet] = useState(new Set());
  const [timeLeft, setTimeLeft] = useState(TOTAL_TIME);
  const [timerStarted, setTimerStarted] = useState(false);
  const [timeEnded, setTimeEnded] = useState(false);
  const [outputLines, setOutputLines] = useState([]);
  const [activeTab, setActiveTab] = useState('output');
  const [customInput, setCustomInput] = useState('');
  const [language, setLanguage] = useState('javascript');
  const [successModal, setSuccessModal] = useState(null); // question obj
  const [failModal, setFailModal] = useState(null); // message
  const [tabWarning, setTabWarning] = useState(false);
  const [tabSwitchCount, setTabSwitchCount] = useState(0);
  const [pointsFlash, setPointsFlash] = useState(null);
  const timerRef = useRef(null);
  const startTimeRef = useRef(null);
  const timeUsedRef = useRef(0);

  // Load saved state
  useEffect(() => {
    const saved = localStorage.getItem(STORAGE_KEY);
    if (saved) {
      try {
        const data = JSON.parse(saved);
        if (data.startTime && (Date.now() - data.startTime) < TOTAL_TIME * 1000) {
          const elapsed = Math.floor((Date.now() - data.startTime) / 1000);
          setTimeLeft(Math.max(0, TOTAL_TIME - elapsed));
          startTimeRef.current = data.startTime;
          if (data.score) setScore(data.score);
          if (data.solved) setSolvedSet(new Set(data.solved));
          if (data.currentQ !== undefined) setCurrentQ(data.currentQ);
        } else {
          localStorage.removeItem(STORAGE_KEY);
        }
      } catch(e) {}
    }
  }, []);

  // Tab switch detection
  useEffect(() => {
    const handler = () => {
      if (document.hidden && phase === 'game') {
        setTabSwitchCount(c => c+1);
        setTabWarning(true);
      }
    };
    document.addEventListener('visibilitychange', handler);
    return () => document.removeEventListener('visibilitychange', handler);
  }, [phase]);

  // Timer
  useEffect(() => {
    if (phase !== 'game') return;
    if (!startTimeRef.current) {
      startTimeRef.current = Date.now();
    }
    timerRef.current = setInterval(() => {
      const elapsed = Math.floor((Date.now() - startTimeRef.current) / 1000);
      const remaining = Math.max(0, TOTAL_TIME - elapsed);
      timeUsedRef.current = elapsed;
      setTimeLeft(remaining);
      // Save state
      localStorage.setItem(STORAGE_KEY, JSON.stringify({
        startTime: startTimeRef.current,
        score, currentQ,
        solved: [...solvedSet]
      }));
      if (remaining === 0) {
        clearInterval(timerRef.current);
        setTimeEnded(true);
      }
    }, 1000);
    return () => clearInterval(timerRef.current);
  }, [phase, score, currentQ, solvedSet]);

  const handleRunResult = useCallback((result) => {
    const lines = [];
    const isIntermediate = result.output && (result.output.startsWith('‚ü≥'));

    if (result.type === 'run') {
      if (isIntermediate) {
        setOutputLines([result.output]);
        return;
      }
      lines.push('$ RUN CODE ‚Äî ' + (language === 'javascript' ? 'JS Sandbox' : 'Fix Validator'));
      lines.push('‚îÄ'.repeat(44));
      if (result.success) {
        result.output.split('\n').forEach(l => lines.push(l));
      } else {
        result.output.split('\n').forEach(l => lines.push(l));
      }
      if (result.time) lines.push(`‚è± Runtime: ${result.time}s`);
      if (result.memory) lines.push(`üíæ Memory: ${Math.round(result.memory / 1024)}KB`);
    } else if (result.type === 'submit') {
      if (isIntermediate) {
        setOutputLines([result.output]);
        return;
      }
      lines.push('$ SUBMIT ‚Äî Running test suite...');
      lines.push('‚îÄ'.repeat(44));
      if (!result.success) {
        result.output.split('\n').forEach(l => lines.push(l));
      } else {
        result.output.split('\n').forEach(l => lines.push(l));
        if (result.time) lines.push(`‚è± Runtime: ${result.time}s`);
        if (result.memory) lines.push(`üíæ Memory: ${Math.round(result.memory / 1024)}KB`);
        if (result.passed) {
          const q = QUESTIONS[currentQ];
          if (!solvedSet.has(currentQ)) {
            const newScore = score + q.points;
            setScore(newScore);
            const newSolved = new Set(solvedSet);
            newSolved.add(currentQ);
            setSolvedSet(newSolved);
            setPointsFlash(`+${q.points}`);
            setTimeout(() => setPointsFlash(null), 1800);
            setSuccessModal(q);
          } else {
            lines.push('‚úÖ Already solved ‚Äî no additional points');
            setOutputLines(lines);
          }
          return;
        } else {
          const failLines = result.output.split('\n').filter(l=>l.startsWith('‚ùå')||l.startsWith('üí•'));
          setFailModal(failLines.join('\n') || 'Test cases failed');
        }
      }
    }
    setOutputLines(lines);
  }, [currentQ, score, solvedSet]);

  const handleNext = () => {
    setSuccessModal(null);
    setOutputLines([]);
    if (currentQ < QUESTIONS.length - 1) {
      setCurrentQ(currentQ + 1);
    } else {
      setPhase('final');
    }
  };

  const handleSuccessClose = () => {
    setSuccessModal(null);
    if (solvedSet.size >= QUESTIONS.length) {
      setPhase('final');
    }
  };

  const handleRestart = () => {
    localStorage.removeItem(STORAGE_KEY);
    startTimeRef.current = null;
    setPhase('loading');
    setCurrentQ(0);
    setScore(0);
    setSolvedSet(new Set());
    setTimeLeft(TOTAL_TIME);
    setTimeEnded(false);
    setOutputLines([]);
    setSuccessModal(null);
    setFailModal(null);
    setTabSwitchCount(0);
  };

  if (phase === 'loading') {
    return <LoadingScreen onComplete={() => { setPhase('game'); startTimeRef.current = startTimeRef.current || Date.now(); }} />;
  }

  if (phase === 'final') {
    return <FinalScreen questions={QUESTIONS} score={score} solvedSet={solvedSet} timeUsed={timeUsedRef.current} onRestart={handleRestart} />;
  }

  const question = QUESTIONS[currentQ];

  return (
    <div style={{display:'flex',flexDirection:'column',height:'100vh',position:'relative',zIndex:1}}>
      <Header
        timeLeft={timeLeft}
        currentQ={currentQ}
        questions={QUESTIONS}
        score={score}
        onQSelect={setCurrentQ}
        solvedSet={solvedSet}
      />
      <div className="app-body">
        <LeftPanel question={question} language={language} />
        <RightPanel
          key={`${question.id}-${currentQ}`}
          question={question}
          disabled={timeEnded}
          onRunResult={handleRunResult}
          outputLines={outputLines}
          activeTab={activeTab}
          setActiveTab={setActiveTab}
          customInput={customInput}
          setCustomInput={setCustomInput}
          language={language}
          setLanguage={setLanguage}
        />
      </div>

      {/* Overlays */}
      {tabWarning && (
        <TabWarning count={tabSwitchCount} onDismiss={() => setTabWarning(false)} />
      )}
      {successModal && (
        <SuccessModal
          question={successModal}
          onNext={handleNext}
          onClose={handleSuccessClose}
          isLast={currentQ >= QUESTIONS.length - 1}
        />
      )}
      {failModal && (
        <FailModal message={failModal} onClose={() => setFailModal(null)} />
      )}
      {timeEnded && !successModal && (
        <div className="times-up" onClick={() => setPhase('final')}>
          <div className="times-up-text">TIME'S UP</div>
          <div style={{fontFamily:"'Share Tech Mono'",color:'var(--text-dim)',marginTop:'20px',fontSize:'0.85rem',letterSpacing:'3px'}}>
            SESSION TERMINATED
          </div>
          <div style={{fontFamily:"'Share Tech Mono'",color:'rgba(255,34,68,0.5)',marginTop:'8px',fontSize:'0.75rem'}}>
            Click to view final score
          </div>
        </div>
      )}
      {pointsFlash && (
        <div className="points-flash">{pointsFlash}</div>
      )}
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
</script>
</body>
</html>
